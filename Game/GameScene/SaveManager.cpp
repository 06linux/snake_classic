#include "Base.h"#include "SaveManager.h"#include "SceneManage.h"static SaveManager* gSaveManager = NULL;SaveManager* SaveManager::Instance(void){    if(NULL == gSaveManager)    {        gSaveManager = new SaveManager();    }        return gSaveManager;}SaveManager::SaveManager(){    // 初始化清零    memset(m_ScoreCurr, 0, sizeof(m_ScoreCurr));    memset(m_ScoreMax, 0, sizeof(m_ScoreMax));        m_GameMode = GameMode_Null;    m_MapLevelId = 0;}SaveManager::~SaveManager(){}void SaveManager::ReadData(){    if(!BaseUtil::hasFile(SaveManager_SavFileName))    {        return;  // 存档不存在    }        char    strMd5[SaveManager_Md5Len] = "";    int     arrLen = 0; // 数组长度        InputStream* inStream = new InputStream(SaveManager_SavFileName, true);    if(inStream)    {        // 读流文件                //----------------------------------------------------        // 读取数字存档 md5 数据        inStream->readArray(strMd5, sizeof(strMd5));                        // 循环读每一个数据        arrLen = inStream->readInt(); // 存档长度        for(int i=0; i<arrLen; i++)        {            m_ScoreCurr[i] = inStream->readInt();        }                // 循环读每一个数据        arrLen = inStream->readInt(); // 存档长度        for(int i=0; i<arrLen; i++)        {            m_ScoreMax[i] = inStream->readInt();        }                        // 释放流        delete inStream;        inStream = NULL;            }        }void SaveManager::WriteData(){    char    strMd5[SaveManager_Md5Len] = "";    int     arrLen = 0; // 数组长度           // 写流文件    OutputStream* outStream = new OutputStream(SaveManager_SavFileName);    if(outStream)    {        //----------------------------------------------------        // 计算数字存档的　md5 数据 ...        // ...                // 写入 md5 数据        outStream->writeArray(strMd5, sizeof(strMd5));                // 循环写每一个数据        arrLen = sizeof(m_ScoreCurr)/sizeof(m_ScoreCurr[0]);    // 写入存档长度        outStream->writeInt(arrLen);        for (int i=0; i<arrLen; i++)        {            outStream->writeInt(m_ScoreCurr[i]);        }                // 循环写每一个数据        arrLen = sizeof(m_ScoreMax)/sizeof(m_ScoreMax[0]);    // 写入存档长度        outStream->writeInt(arrLen);        for (int i=0; i<arrLen; i++)        {            outStream->writeInt(m_ScoreMax[i]);        }                        // 释放流        delete outStream;        outStream = NULL;    }}//int SaveManager::GetNumData(SavNumIndex _savIndex)//{//    if(_savIndex > SavNum_Null && _savIndex < SavNum_End)//    {//        int num =m_ScoreCurr[_savIndex];//        NumEncription(&num, SaveManager_Key);       // 返回解密后的数据//        return num;//    }//    //    return 0;//}////void SaveManager::SetNumData(SavNumIndex _savIndex, int _newData)//{//    if(_savIndex > SavNum_Null && _savIndex < SavNum_End)//    {//        m_ScoreCurr[_savIndex] = NumEncription(&_newData, SaveManager_Key);  // 存储数据加密//    }//}//const char* SaveManager::GetStrData(SavStrIndex _savIndex)//{//    if(_savIndex > SavStr_Null && _savIndex < SavStr_End)//    {//        strncpy(m_StrReturn, m_StrData[_savIndex], sizeof(m_StrReturn));//        //        // 将返回的数据进行解密//        StrEncription(m_StrReturn, sizeof(m_StrReturn), SaveManager_Key);//        //        return m_StrReturn;//    }//    //    return NULL;//}////void SaveManager::SetStrData(SavStrIndex _savIndex, const char* _newData)//{//    if(_savIndex > SavStr_Null && _savIndex < SavStr_End)//    {//       if(_newData && strlen(_newData) < SaveManager_StrDataLen-1)//       {//           strcpy(m_StrData[_savIndex], _newData);//           //           // 存储加密//           StrEncription(m_StrData[_savIndex], sizeof(m_StrData[_savIndex]), SaveManager_Key);//       }//    }//}/* *    函数原形    void StrEncription(char* _pchSrc, int _nLen, char _chKey); *    表头文件    #include<assert.h> *                        #include<string.h> *    函数描述    异或运算加密函数,直接修改原串。 *                        将一个字符串的每一个字符和一个特定的字符异或运算 *                        第一次异或----加密 *                        第二次异或----解密 *        参 数    _pchSrc，要加密的原串 *                        _nLen, 原串的长度，用 strlen() 函数可以得到。 *                        _chKey，加密的密钥 */const char* SaveManager::StrEncription(char* _pchSrc, int _nLen, char _chKey){    assert( NULL != _pchSrc );        for(int i=0; i<_nLen; i++)    {        _pchSrc[i] = _pchSrc[i] ^ _chKey; // 异或运算    }        return _pchSrc;}// 数字加密int SaveManager::NumEncription(int* _pNum, char _chKey){    assert( NULL != _pNum );        _pNum[0] = _pNum[0] ^ _chKey; // 异或运算        return  _pNum[0];}