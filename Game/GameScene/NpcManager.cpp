#include "Base.h"#include "NpcManager.h"#include "Npc.h"#include "SaveManager.h"#include "GamePlay.h"#include "SceneManage.h"static NpcManager* gNpcManager = NULL;NpcManager* NpcManager::Instance(void){    if(NULL == gNpcManager)    {        gNpcManager = new NpcManager();    }        return gNpcManager;}NpcManager::NpcManager(){    m_pMapBuffer = NULL;}NpcManager::~NpcManager(){    FreeAll();}/* *	加载一个精灵到地图中去 *	_idExcel        excel 表 id *  _mapPos         地图中的位置 */Npc*  NpcManager::Load(int _idExcel, Vec2 _mapPos, NpcType _npcType, int _zOder){    if(_npcType <= NpcType_Null || _npcType >= NpcType_End)    {        return NULL;    }    if(NULL == GamePlay::Instance()->m_Map)    {        return NULL;    }        Npc*  obj = new Npc();    obj->m_NpcType = (NpcType)_npcType;    obj->LoadNpc(_idExcel);         // 此函数会根据数据表中的配置，从新更新npc 的类型    obj->setPosition(_mapPos);            // 添加到地图中    GamePlay::Instance()->m_Map->addChild(obj, _zOder);        // 添加到  vector 中 (根据当前对象的不同类型，添加到同的容器中)    if(_npcType >= NpcType_Npc_Start && _npcType <= NpcType_Npc_End )    {        m_vNpc.push_back(obj);    }    else if(_npcType >= NpcType_Show_Start && _npcType <= NpcType_Show_End)    {        m_vShow.push_back(obj);    }    else if(_npcType >= NpcType_Bullet_Start && _npcType <= NpcType_Bullet_end)    {        m_vBullet.push_back(obj);    }    else    {        m_vNpc.push_back(obj);    }       return obj;}Npc* NpcManager::LoadByMapGrid(int _idExcel, Vec2 _mapGrid, NpcType _npcType, int _zOder){    Vec2 mapPos = GamePlay::Instance()->m_Map->PointSwitch_MapGrid2Pos(_mapGrid);    return Load(_idExcel, mapPos, _npcType, _zOder);}void  NpcManager::Free(int _idUnique){    Npc*   objDel = NULL;        vector<Npc*>::iterator it;            if(NULL == objDel)    {        for(it = m_vNpc.begin(); it != m_vNpc.end(); it++)        {            Npc* obj = *it;                        if(obj->m_IdUnique == _idUnique)            {                objDel = obj;                it = m_vNpc.erase(it);  // 删除后，必须重新设置 it 的值                break;            }        }    }        if(NULL == objDel)    {        for(it = m_vShow.begin(); it != m_vShow.end(); it++)        {            Npc* obj = *it;                        if(obj->m_IdUnique == _idUnique)            {                objDel = obj;                it = m_vShow.erase(it);  // 删除后，必须重新设置 it 的值                break;            }        }    }        if(NULL == objDel)    {        for(it = m_vBullet.begin(); it != m_vBullet.end(); it++)        {            Npc* obj = *it;                        if(obj->m_IdUnique == _idUnique)            {                objDel = obj;                it = m_vBullet.erase(it);  // 删除后，必须重新设置 it 的值                break;            }        }    }        if(objDel)    {        objDel->stopAllActions();        objDel->FreeNpc();                // 先从地图中删除        GamePlay::Instance()->m_Map->removeChild(objDel, true);                objDel->release();        objDel = NULL;    }}void  NpcManager::FreeByMapGrid(Vec2 _mapGrid, NpcType _npcType){    if(_npcType <= NpcType_Null || _npcType >= NpcType_End)    {        return ;    }        if(NULL == GamePlay::Instance()->m_Map)    {        return ;    }        Npc*   objDel = NULL;    vector<Npc*>::iterator it;        if(NpcRunDir_Null == _npcType || (_npcType >= NpcType_Npc_Start && _npcType <= NpcType_Npc_End) )    {        for(it = m_vNpc.begin(); it != m_vNpc.end(); it++)        {            Npc* obj = *it;            Vec2 mapGrid_Obj = obj->GetMapGrid();                        if(BaseUtil::posEqual(mapGrid_Obj, _mapGrid))            {                objDel = obj;                it = m_vNpc.erase(it);  // 删除后，必须重新设置 it 的值                break;            }        }    }        if(NpcRunDir_Null == _npcType || (_npcType >= NpcType_Show_Start && _npcType <= NpcType_Show_End))    {        for(it = m_vShow.begin(); it != m_vShow.end(); it++)        {            Npc* obj = *it;                        Vec2 mapGrid_Obj = obj->GetMapGrid();                        if(BaseUtil::posEqual(mapGrid_Obj, _mapGrid))            {                objDel = obj;                it = m_vShow.erase(it);  // 删除后，必须重新设置 it 的值                break;            }        }    }        if(NpcRunDir_Null == _npcType || (_npcType >= NpcType_Bullet_Start && _npcType <= NpcType_Bullet_end))    {        for(it = m_vBullet.begin(); it != m_vBullet.end(); it++)        {            Npc* obj = *it;                        Vec2 mapGrid_Obj = obj->GetMapGrid();                        if(BaseUtil::posEqual(mapGrid_Obj, _mapGrid))            {                objDel = obj;                it = m_vBullet.erase(it);  // 删除后，必须重新设置 it 的值                break;            }        }    }            if(objDel)    {        objDel->stopAllActions();        objDel->FreeNpc();                // 先从地图中删除        GamePlay::Instance()->m_Map->removeChild(objDel, true);                objDel->release();        objDel = NULL;    }}void  NpcManager::FreeAll(){    vector<Npc*>::iterator it;        for(it = m_vNpc.begin(); it != m_vNpc.end(); it++)    {        Npc* obj = *it;                obj->stopAllActions();        obj->FreeNpc();                // 先从地图中删除        GamePlay::Instance()->m_Map->removeChild(obj, true);                obj->release();        obj = NULL;    }    // 清空容器    m_vNpc.clear();        for(it = m_vShow.begin(); it != m_vShow.end(); it++)    {        Npc* obj = *it;                obj->stopAllActions();        obj->FreeNpc();                // 先从地图中删除        GamePlay::Instance()->m_Map->removeChild(obj, true);                obj->release();        obj = NULL;    }    // 清空容器    m_vShow.clear();            for(it = m_vBullet.begin(); it != m_vBullet.end(); it++)    {        Npc* obj = *it;                obj->stopAllActions();        obj->FreeNpc();                // 先从地图中删除        GamePlay::Instance()->m_Map->removeChild(obj, true);                obj->release();        obj = NULL;    }    // 清空容器    m_vBullet.clear();            // 缓冲数据    NpcManager::Instance()->MapBuffer_Free();}Npc* NpcManager::Get(int _idUnique){    Npc*   retObj = NULL;        vector<Npc*>::iterator it;        if(NULL == retObj)    {        for(it = m_vNpc.begin(); it != m_vNpc.end(); it++)        {            Npc* obj = *it;                        if(obj->m_IdUnique == _idUnique)            {                retObj = obj;                break;            }        }    }    if(NULL == retObj)    {        for(it = m_vShow.begin(); it != m_vShow.end(); it++)        {            Npc* obj = *it;                        if(obj->m_IdUnique == _idUnique)            {                retObj = obj;                break;            }        }    }        if(NULL == retObj)    {        for(it = m_vBullet.begin(); it != m_vBullet.end(); it++)        {            Npc* obj = *it;                        if(obj->m_IdUnique == _idUnique)            {                retObj = obj;                break;            }        }    }        return retObj;}Npc* NpcManager::GetByMapGrid(Vec2 _mapGrid, NpcType _npcType){      if(nullptr == GamePlay::Instance()->m_Map)    {        return nullptr;    }        vector<Npc*>::iterator it;        if(NpcRunDir_Null == _npcType || (_npcType >= NpcType_Npc_Start && _npcType <= NpcType_Npc_End))    {        for(it = m_vNpc.begin(); it != m_vNpc.end(); it++)        {            Npc* obj = *it;            Vec2 mapGrid_Obj = obj->GetMapGrid();                        if(BaseUtil::posEqual(mapGrid_Obj, _mapGrid))            {                if( NpcRunDir_Null == _npcType ||                    NpcType_Npc_Start == _npcType ||                    NpcType_Npc_End == _npcType                   )                {                    return obj;                }                else                {                    // 指定的 npc 类型                    if(obj->m_NpcType == _npcType)                    {                        return obj;                    }                }            }        }    }        if(NpcRunDir_Null == _npcType || (_npcType >= NpcType_Show_Start && _npcType <= NpcType_Show_End))    {        for(it = m_vShow.begin(); it != m_vShow.end(); it++)        {            Npc* obj = *it;                        Vec2 mapGrid_Obj = obj->GetMapGrid();                        if(BaseUtil::posEqual(mapGrid_Obj, _mapGrid))            {                if( NpcRunDir_Null == _npcType ||                   NpcType_Show_Start == _npcType ||                   NpcType_Show_End == _npcType                   )                {                    return obj;                }                else                {                    // 指定的 npc 类型                    if(obj->m_NpcType == _npcType)                    {                        return obj;                    }                }            }        }    }        if(NpcRunDir_Null == _npcType || (_npcType >= NpcType_Bullet_Start && _npcType <= NpcType_Bullet_end))    {        for(it = m_vBullet.begin(); it != m_vBullet.end(); it++)        {            Npc* obj = *it;                        Vec2 mapGrid_Obj = obj->GetMapGrid();                        if(BaseUtil::posEqual(mapGrid_Obj, _mapGrid))            {                if( NpcRunDir_Null == _npcType ||                    NpcType_Bullet_Start == _npcType ||                    NpcType_Bullet_end == _npcType                   )                {                    return obj;                }                else                {                    // 指定的 npc 类型                    if(obj->m_NpcType == _npcType)                    {                        return obj;                    }                }            }        }    }        return nullptr;}int NpcManager::GetCount(NpcType _npcType){    int retCount = 0;        vector<Npc*>::iterator it;        if((_npcType >= NpcType_Npc_Start && _npcType <= NpcType_Npc_End))    {        if(NpcType_Npc_Start == _npcType || NpcType_Npc_End == _npcType)        {            retCount += m_vNpc.size();   //  当前类型下，所有 npc 的各数        }        else        {   // 制定类型 npc 的个数            for(it = m_vNpc.begin(); it != m_vNpc.end(); it++)            {                Npc* obj = *it;                if(_npcType == obj->m_NpcType)                {                    retCount++;                }            }        }    }        if((_npcType >= NpcType_Show_Start && _npcType <= NpcType_Show_End))    {        if(NpcType_Show_Start == _npcType || NpcType_Show_End == _npcType)        {            retCount += m_vShow.size();        }        else        {            for(it = m_vShow.begin(); it != m_vShow.end(); it++)            {                Npc* obj = *it;                if(_npcType == obj->m_NpcType)                {                    retCount++;                }            }        }    }        if((_npcType >= NpcType_Bullet_Start && _npcType <= NpcType_Bullet_end))    {        if(NpcType_Bullet_Start == _npcType || NpcType_Bullet_end == _npcType)        {            retCount += m_vBullet.size();        }        else        {            for(it = m_vBullet.begin(); it != m_vBullet.end(); it++)            {                Npc* obj = *it;                if(_npcType == obj->m_NpcType)                {                    retCount++;                }            }        }    }        return retCount;}void  NpcManager::UpdateLogic(float _dt){        Npc_UpdateRun(_dt);    //    vector<Npc*>  vecFree;//    vector<Npc*>::iterator it;//    //    for(it = m_MapTx.begin(); it != m_MapTx.end(); it++)//    {//        Npc* obj = *it;//        obj->UpdateLogic(_dt);//        //        if(obj->m_IsFreeSelf)//        {//            vecFree.push_back(obj);//        }//    }    //    // 检测释放//    for(it = vecFree.begin(); it != vecFree.end(); it++)//    {//        Npc* obj = *it;//        obj->DoFreeSelf();//    }//    vecFree.clear();    }bool  NpcManager::TouchPressed(Vec2 _touchPos){    bool retDoTouch = false;        if(NULL == GamePlay::Instance()->m_Map)    {        return retDoTouch;    }        retDoTouch = true;    //    CCSize mapSize = GamePlay::Instance()->m_Map->m_mapSize;//    //    Vec2 mapGrid_Touch = GamePlay::Instance()->m_Map->PointSwitch_Screen2MapGrid(_touchPos);//    //    // 判断地图坐标的合法性//    if(mapGrid_Touch.x < 0 || mapGrid_Touch.x >= mapSize.width ||//       mapGrid_Touch.y < 0 || mapGrid_Touch.y >= mapSize.height//       )//    {//        return retDoTouch;//    }          return retDoTouch;    }bool  NpcManager::TouchReleased(Vec2 _touchPos){    bool retDoTouch = false;        if(NULL == GamePlay::Instance()->m_Map)    {        return retDoTouch;    }          return retDoTouch;}#pragma mark -#pragma mark MapBuffervoid NpcManager::MapBuffer_Init(Size _mapSize){    MapBuffer_Free();        m_pMapBuffer = MALLOCXX((int)_mapSize.height, (int)_mapSize.width, int);}void NpcManager::MapBuffer_Free(){    FREEXX(m_pMapBuffer);}void NpcManager::MapBuffer_Refresh(){    if(NULL == m_pMapBuffer) return ;        // 先清除缓冲数组    for(int i=0; i<ARRLEN(m_pMapBuffer); i++)   // 行    {        for(int j=0; j<ARRLEN(m_pMapBuffer[i]); j++) // 列        {            m_pMapBuffer[i][j] = 0;		// 默认可以通过        }    }        vector<Npc*>::iterator it;    for(it = m_vNpc.begin(); it != m_vNpc.end(); it++)    {        Npc*    obj = *it;                Vec2     mapGrid_Obj = obj->GetMapGrid();                // 防止数组越界        if(mapGrid_Obj.y >= 0 && mapGrid_Obj.y < ARRLEN(m_pMapBuffer)   &&           mapGrid_Obj.x >= 0 && mapGrid_Obj.x < ARRLEN(m_pMapBuffer[(int)mapGrid_Obj.y]) )        {            if(0 == m_pMapBuffer[(int)mapGrid_Obj.y][(int)mapGrid_Obj.x])            {                m_pMapBuffer[(int)mapGrid_Obj.y][(int)mapGrid_Obj.x] = obj->m_IdExcel;            }            else            {                printf("Error: NpcManager::MapBuffer_Refresh, has chone he ...\n");            }        }    }}int NpcManager::MapBuffer_Get(Vec2 _mapGrid){    int retType = 0;        if(m_pMapBuffer)    {        if(_mapGrid.y >= 0 && _mapGrid.y < ARRLEN(m_pMapBuffer)   &&           _mapGrid.x >= 0 && _mapGrid.x < ARRLEN(m_pMapBuffer[(int)_mapGrid.y]) )        {            retType = m_pMapBuffer[(int)_mapGrid.y][(int)_mapGrid.x];        }    }        return retType;}void NpcManager::MapBuffer_Set(Vec2 _mapGrid, int _type){    if(m_pMapBuffer)    {        if(_mapGrid.y >= 0 && _mapGrid.y < ARRLEN(m_pMapBuffer)   &&           _mapGrid.x >= 0 && _mapGrid.x < ARRLEN(m_pMapBuffer[(int)_mapGrid.y]) )        {            m_pMapBuffer[(int)_mapGrid.y][(int)_mapGrid.x] = _type;        }    }}void NpcManager::MapBuffer_Clear(){    // 先清除缓冲数组    for(int i=0; i<ARRLEN(m_pMapBuffer); i++)   // 行    {        for(int j=0; j<ARRLEN(m_pMapBuffer[i]); j++) // 列        {            m_pMapBuffer[i][j] = 0;		// 默认可以通过        }    }}#pragma mark -#pragma mark Game Logicvoid NpcManager::Npc_Init(Vec2 _mapGridHead, int _idExcelHead, int _IdExcelBody, NpcRunDir _headDir, int _bodyLen){    if(_bodyLen < 1)    {        _bodyLen = 1;  // 最少一个    }        // 加载蛇头    Npc* objSnakeHead = LoadByMapGrid(_idExcelHead, _mapGridHead, NpcType_Npc_Start, MapZOder_Npc);    objSnakeHead->m_RunDir = _headDir;        Vec2 mapGridBody = _mapGridHead;    Npc* objHead = objSnakeHead;        for(int i=0; i< _bodyLen; i++)    {        switch (_headDir)        {            case NpcRunDir_Up:            {                mapGridBody.y += 1;            }                break;            case NpcRunDir_Down:            {                mapGridBody.y -= 1;            }                break;            case NpcRunDir_Left:            {                mapGridBody.x += 1;            }                break;            case NpcRunDir_Right:            {                mapGridBody.x -= 1;            }                break;            default:            {                mapGridBody.x += 1;            }                break;        }                        // 初始化蛇身        Npc* objBody = LoadByMapGrid(_IdExcelBody, mapGridBody, NpcType_Npc_Start, MapZOder_Npc);                objHead->m_Next = objBody;        objHead = objBody;    }}void NpcManager::Npc_UpdateRun(float _dt){    if(Npc_InMove())    {        return;    }        Npc* objSnakeHead = Npc_GetSnakeHead();    if(objSnakeHead)    {        // 更新地图设置的方向逻辑        Npc_SetHeadDir(GamePlay::Instance()->Map_GetTagDir(objSnakeHead->GetMapGrid()));                NpcRunDir   runDir = objSnakeHead->m_RunDir;        Vec2        mapGridDest = objSnakeHead->GetMapGrid();   // 移动的目标位置 (head, 永远使用自己当前的物理位置来计算目标位置)        Npc*        obj = objSnakeHead;                // 计算蛇头移动的目标位置        switch (runDir)        {            case NpcRunDir_Up:            {                mapGridDest.y -= 1;            }                break;            case NpcRunDir_Down:            {                mapGridDest.y += 1;            }                break;            case NpcRunDir_Left:            {                mapGridDest.x -= 1;            }                break;            case NpcRunDir_Right:            {                mapGridDest.x += 1;            }                break;            default:            {            }                break;        }                        Npc_CheckWin();        Npc_CheckDead(mapGridDest);        Npc_DoEat(mapGridDest);     // 更新吃物品逻辑        Npc_AddFood();              // 增加食物                        //CCLOG("NpcManager::Npc_UpdateRun -----------------------------");                // 遍历所有的节点--更新移动位置        while (obj)        {            Vec2 mapGridCurr = obj->GetLogicGrid();                        //CCLOG("NpcManager::Npc_UpdateRun mapGridCurr = (%f,%f)", mapGridCurr.x, mapGridCurr.y);            //CCLOG("NpcManager::Npc_UpdateRun mapGridDest = (%f,%f)", mapGridDest.x, mapGridDest.y);                        if(obj->m_StopMove > 0)            {                obj->m_StopMove -= 1;            }            else            {                obj->MoveToMapGrid(mapGridDest, 0.3f);            }                        obj = obj->m_Next;            mapGridDest = mapGridCurr;  // 下一个节点的目标位置        }                //CCLOG("NpcManager::Npc_UpdateRun -----------------------------");    }}Npc* NpcManager::Npc_GetSnakeHead(){    vector<Npc*>::iterator it;        for(it = m_vNpc.begin(); it != m_vNpc.end(); it++)    {        Npc* obj = *it;        if(NpcType_Npc_SnakeHead == obj->m_NpcType)        {            return obj;        }    }        return nullptr;}void NpcManager::Npc_SetHeadDir(NpcRunDir _dir){    if(NpcRunDir_Null == _dir)    {        return;    }        Npc* objHead = Npc_GetSnakeHead();    if(objHead)    {        Vec2 mapGrid = objHead->GetMapGrid();        if(mapGrid.x < 0 || mapGrid.x >= GamePlay::Instance()->m_Map->m_mapSize.width ||           mapGrid.y < 0 || mapGrid.y >= GamePlay::Instance()->m_Map->m_mapSize.height           )        {            return;  // 在地图区域外，不能改变方向        }                // 不可以掉头行走        if(NpcRunDir_Up == objHead->m_RunDir && NpcRunDir_Down == _dir)        {            return;        }        if(NpcRunDir_Right == objHead->m_RunDir && NpcRunDir_Left == _dir)        {            return;        }        if(NpcRunDir_Down == objHead->m_RunDir && NpcRunDir_Up == _dir)        {            return;        }        if(NpcRunDir_Left == objHead->m_RunDir && NpcRunDir_Right == _dir)        {            return;        }                Vec2 mapGridDest = mapGrid;               // 计算蛇头移动的目标位置        switch (_dir)        {            case NpcRunDir_Up:            {                mapGridDest.y -= 1;            }                break;            case NpcRunDir_Down:            {                mapGridDest.y += 1;            }                break;            case NpcRunDir_Left:            {                mapGridDest.x -= 1;            }                break;            case NpcRunDir_Right:            {                mapGridDest.x += 1;            }                break;            default:            {            }                break;        }                Npc* objDest = GetByMapGrid(mapGridDest, NpcType_Npc_Start);        if(objDest && objDest->m_IdUnique == objHead->m_Next->m_IdUnique)        {            return;   // 不能后退        }                objHead->m_RunDir = _dir;    }}void NpcManager::Npc_DoEat(Vec2 _mapGrid){    Npc* objEat = GetByMapGrid(_mapGrid, NpcType_Bullet_Start);    if(objEat && objEat->m_NpcType == NpcType_Bullet_Food)  // 可以吃    {        BaseMusic::Instance()->SoundControl(sound_EatFood);        Free(objEat->m_IdUnique);        GamePlay::Instance()->Map_AddScore(1);          // 增加分数                Npc* objSnakeHead = Npc_GetSnakeHead();        if(objSnakeHead)        {            Npc* objNext = objSnakeHead->m_Next;            Npc* objNew = LoadByMapGrid(2, objNext->GetMapGrid(), NpcType_Npc_SnakeBody, MapZOder_Npc);                        objSnakeHead->m_Next = objNew;            objNew->m_Next = objNext;                        // 遍历所有的节点，后面的所有节点，走暂停一次移动            while (objNext)            {                objNext->m_StopMove += 1;                objNext = objNext->m_Next;            }        }    }}void NpcManager::Npc_CheckDead(Vec2 _mapGrid){    // 判断是否撞到墙    int clipId = GamePlay::Instance()->m_Map->GetTileGID(MAP_LAYER_TAG, _mapGrid);    if(MapTag_NoPass == clipId)    {        //CCLOG("NpcManager::Npc_CheckDead, Game Over .....");        BaseMusic::Instance()->SoundControl(sound_Dead);        GamePlay::Instance()->UI_JieSuanMenuSet(true);                return;    }        // 判断是否撞到自己身体    Npc* obj = GetByMapGrid(_mapGrid, NpcType_Npc_SnakeBody);    if(obj && obj->m_NpcType == NpcType_Npc_SnakeBody)    {        //CCLOG("NpcManager::Npc_CheckDead, Game Over .....");        BaseMusic::Instance()->SoundControl(sound_Dead);        GamePlay::Instance()->UI_JieSuanMenuSet(true);                return;    }    }void NpcManager::Npc_AddFood(){    if( GetCount(NpcType_Bullet_Food) == 0 &&   // 地图上的食物为 0        GamePlay::Instance()->Map_CreateNpcGetCount() > 0)    {        Vec2 mapGridChuBing = GamePlay::Instance()->Map_CreateNpcGet();                // 最多随机 16 次        for(int i=0; i<16; i++)        {            // 检测出兵点之上，是否存在蛇的身体，如果存在，随机生产一个            if(GetByMapGrid(mapGridChuBing, NpcType_Npc_SnakeHead) ||               GetByMapGrid(mapGridChuBing, NpcType_Npc_SnakeBody))            {                mapGridChuBing = GamePlay::Instance()->Map_CreateNpcGet();            }            else            {                break; // 出兵点可以使用            }        }                if(GetByMapGrid(mapGridChuBing, NpcType_Npc_SnakeHead) ||           GetByMapGrid(mapGridChuBing, NpcType_Npc_SnakeBody))        {            mapGridChuBing = Vec2(-100, -100);        }                if(!BaseUtil::posEqual(mapGridChuBing, Vec2(-100, -100)))        {            //GamePlay::Instance()->Map_CreateNpcDel(mapGridChuBing);  // 删除当前出兵点            LoadByMapGrid(3, mapGridChuBing, NpcType_Bullet_Start, MapZOder_Bullet); // 创建食物        }    }}// 检测游戏是否胜利void NpcManager::Npc_CheckWin(){    if( GetCount(NpcType_Bullet_Food) == 0 &&  GamePlay::Instance()->Map_CreateNpcGetCount() == 0)    {         CCLOG("NpcManager::Npc_DoEat, Game Win .....");    }}int NpcManager::Npc_GetCount(){    return (int)m_vNpc.size();}Npc* NpcManager::Npc_GetByRand(){    Npc* retObj = NULL;        if(m_vNpc.size() == 1)    {        retObj = m_vNpc[0];  // 就一个对象    }    else if(m_vNpc.size() > 1)    {        int     maxIndex = m_vNpc.size(); // 最大索引位置        int     startIndex = BaseUtil::randNum2(1, maxIndex+1, 0)-1;  // 随机一个位置        int     currIndex = (startIndex)%maxIndex;                if(currIndex >= 0 &&  currIndex < m_vNpc.size() )        {            retObj = m_vNpc[currIndex];        }    }        return retObj;}bool NpcManager::Npc_InMove(){    vector<Npc*>::iterator it;        for(it = m_vNpc.begin(); it != m_vNpc.end(); it++)    {        Npc* obj = *it;        if(obj->IsInMove())        {            return true;  // 存在移动的精灵        }    }        return false;}