#include "Base.h"#include "BaseTiledMap.h"BaseTiledMap* BaseTiledMap::create(const std::string& tmxFile){    BaseTiledMap *ret = new (std::nothrow) BaseTiledMap();    if (ret->loadMap(tmxFile))    {        ret->autorelease();        return ret;    }    CC_SAFE_DELETE(ret);    return nullptr;}BaseTiledMap::BaseTiledMap(){    m_mapScale = 1;    m_mapSize=Size(0, 0);    m_mapTileSize=Size(0, 0);    m_mapOff = Vec2(0,0);        m_LocatW = 64;    m_LocatH = 64;}BaseTiledMap::~BaseTiledMap(){    m_mapScale = 1;    m_mapSize=Size(0, 0);    m_mapTileSize=Size(0, 0);    m_mapOff = Vec2(0,0);}int BaseTiledMap::loadMap(const std::string& _strMapName){    #ifdef GAME_DEBUG_MODE	printf("BaseTiledMap::loadMap, mapName = %s \n", _strMapName.c_str());#endif        assert( _strMapName.length() > 0 );        this->initWithTMXFile(_strMapName);    m_mapSize = getMapSize();    m_mapOff = Vec2(0,0);        // 处理高清模式下，地图切片的大小    m_mapTileSize = getTileSize();//    if(DISP_RETINA == gDisplayMode)//    {//        m_mapTileSize.width = m_mapTileSize.width/2;//        m_mapTileSize.height = m_mapTileSize.height/2;//    }        // 默认距离屏幕边界的距离，小于 2个地图格子的时候，会触发地图移动    m_LocatW = m_mapTileSize.width*2;    m_LocatH = m_mapTileSize.height*2;        m_mapScale = 1.0f;    this->setScale(m_mapScale);    this->setPosition(Vec2(0,0));        return 1;}// 坐标转换Vec2 BaseTiledMap::PointSwitch_MapGrid2Pos(Vec2 _mapGrid){    // + 0.5 是为了返回 地图网格中心点的坐标    return Vec2( (_mapGrid.x+0.5)* m_mapTileSize.width , (m_mapSize.height - (_mapGrid.y+0.5)) * m_mapTileSize.height );}Vec2 BaseTiledMap::PointSwitch_Pos2MapGrid(Vec2 _mapPos){    Vec2 retGrid = Vec2( (int)(_mapPos.x/m_mapTileSize.width) ,  m_mapSize.height - 1 - (int)(_mapPos.y/m_mapTileSize.height));        if(_mapPos.x < 0)    {        retGrid.x -= 1;    }        if(_mapPos.y < 0)    {        retGrid.y += 1;    }        return retGrid;}Vec2 BaseTiledMap::PointSwitch_MapGrid2Screen(Vec2 _mapGrid){    Vec2 mapPos = PointSwitch_MapGrid2Pos(_mapGrid);    return PointSwitch_Map2Screen(mapPos);}Vec2 BaseTiledMap::PointSwitch_Screen2MapGrid(Vec2 _screenPos){    Vec2 mapPos = PointSwitch_Screen2Map(_screenPos);    return PointSwitch_Pos2MapGrid(mapPos);}Vec2 BaseTiledMap::PointSwitch_Screen2Map(Vec2 _screenPos){    return convertToNodeSpace(_screenPos); // 转换成当前节点上的坐标}Vec2 BaseTiledMap::PointSwitch_Map2Screen(Vec2 _mapPos){    Vec2 worldPoint = convertToWorldSpace(_mapPos);        // 优化保留，不用在使用了。    //CGPoint screenPosition = [[CCDirector sharedDirector] convertToUI:worldPoint];    //screenPosition.y = [BaseUtil ScreenHeight] - screenPosition.y;   // 转换 open gl 坐标系 到 cocos2d 坐标系        return worldPoint;}// 备注：当地图大于屏幕的时候，地图的偏移坐标只能是负数Vec2 BaseTiledMap::MapMove_PositionGet(Vec2 _roleMapPos){    Vec2 retPos = Vec2(0,0);    Vec2 rolePos_Screen = PointSwitch_Map2Screen(_roleMapPos);   // 当前角色显示在屏幕的坐标    Vec2 mapOffPos = Vec2(-(_roleMapPos.x - rolePos_Screen.x), -(_roleMapPos.y - rolePos_Screen.y) );  // 当前地图的偏移        // 更新 x坐标 偏移    if(m_mapTileSize.width*m_mapSize.width <= SCREEN_W)    {        // 居中显示        retPos.x = SCREEN_W/2.0f - m_mapTileSize.width*m_mapSize.width/2.0f;    }    else    {        // 左边界，主角向左移动，地图向右偏移        if(rolePos_Screen.x < m_LocatW)        {            retPos.x = mapOffPos.x + (m_LocatW-rolePos_Screen.x);        }        // 右边界，主句向右移动, 地图向左偏移        else if( rolePos_Screen.x > (SCREEN_W - m_LocatW) )        {            retPos.x = mapOffPos.x - (rolePos_Screen.x - (SCREEN_W-m_LocatW));        }                // 地图偏移左右越界判断        if(retPos.x > 0)        {            retPos.x = 0;        }        else if(retPos.x < -m_mapTileSize.width*m_mapSize.width)        {            retPos.x = -m_mapTileSize.width*m_mapSize.width;        }    }        // 更新 y 坐标偏移    if(m_mapTileSize.height*m_mapSize.height <= SCREEN_H)    {        // 居中显示        retPos.y = SCREEN_H/2.0f - m_mapTileSize.height*m_mapSize.height/2.0f;    }    else    {        // 下边界，主角向下移动，地图向上偏移        if(rolePos_Screen.y < m_LocatH)        {            retPos.y = mapOffPos.y + (m_LocatH-rolePos_Screen.y);        }        // 上边界，主句向上移动, 地图向下偏移        else if( rolePos_Screen.y > (SCREEN_H - m_LocatH) )        {            retPos.y = mapOffPos.y - (rolePos_Screen.y - (SCREEN_H-m_LocatH));        }                // 地图偏移左右越界判断        if(retPos.y > 0)        {            retPos.y = 0;        }        else if(retPos.y < -m_mapTileSize.height*m_mapSize.height)        {            retPos.y = -m_mapTileSize.height*m_mapSize.height;        }    }        return retPos;}void BaseTiledMap::MapMove_PositionSet(Vec2 _rolePos){    setPosition(MapMove_PositionGet(_rolePos));}int BaseTiledMap::GetTileGID(const std::string& _layerName, Vec2 _mapGrid){    if(_mapGrid.x >=0 && _mapGrid.x < m_mapSize.width &&       _mapGrid.y >=0 && _mapGrid.y < m_mapSize.height )    {        TMXLayer* objLayer = this->getLayer(_layerName);        if(objLayer)        {            int firstGid = 0;            TMXTilesetInfo* info = objLayer->getTileSet();            if(info)            {                firstGid = info->_firstGid;            }            int clipId = objLayer->getTileGIDAt(_mapGrid);            if(clipId > 0)            {                return (1+clipId-firstGid);            }        }    }        return 0;  // 不存在切片}// 得到地图切片对应的属性设置信息Value BaseTiledMap::GetGidProperties(int _gid, const std::string _key){    Value vObj = getPropertiesForGID(_gid);    if(vObj.getType() == Value::Type::MAP)    {        ValueMap& map = vObj.asValueMap();        return  map[_key];    }        return Value();  // 找不到，返回一个空的值}// 防止地图变形， x,y 方向缩放系数相同Vec2 BaseTiledMap::GetScale(cocos2d::Size _showSize, bool _fixWH){    Vec2 retScale = Vec2(1,1);        if(_showSize.width > 0 && _showSize.height > 0)    {        Size mapSize = m_mapSize;        Size mapTitleSize = m_mapTileSize;        float mapWidth = mapSize.width*mapTitleSize.width;        float mapHeight = mapSize.height*mapTitleSize.height;        float scaleX = 1.0f;        float scaleY = 1.0f;                if(_showSize.width < mapWidth && mapWidth > 0)  // 需要缩小        {            scaleX  = _showSize.width/mapWidth;        }                if(_showSize.height < mapHeight && mapHeight > 0)        {            scaleY = _showSize.height/mapHeight;        }                if(_fixWH)        {            scaleX = MIN(scaleX, scaleY);            scaleY = MIN(scaleX, scaleY);        }                retScale = Vec2(scaleX, scaleY);    }        return retScale;}