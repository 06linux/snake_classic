/* *  BaseUtil.h *  CCGame * *  Created by linux_wuliqiang@163.com on 2015-03-30. *  Copyright 2015 Beijing. All rights reserved. * *	游戏工具函数的封装 *	凡是游戏中，可以单独提取出来的工具函数，都建议放到此文件中 */#ifndef __BASE_UITL_H__#define __BASE_UITL_H__#include "cocos2d.h"#include "BaseTypeDefine.h"using namespace cocos2d;/* 基本类型以及常量定义定义 */typedef unsigned char U8;typedef unsigned short int U16;typedef unsigned int U32;typedef signed char S8;typedef signed short int S16;typedef signed int S32;typedef char STR;typedef unsigned short int WSTR;typedef enum{    DrawPercentDir_Null = 0,        DrawPercentDir_Up,    DrawPercentDir_Down,    DrawPercentDir_Left,    DrawPercentDir_Right,        DrawPercentDir_End    }DrawPercentDir;typedef enum{    Dir_Null = 0,        // 顺时针方向旋转    Dir_Up,    Dir_Right,    Dir_Down,    Dir_Left,        Dir_End    }Dir;class BaseUtil{public:        // 一维内存的分配和释放    static void*    BaseMalloc(S32 size);       // 对内存的释放和分配进行了特殊处理，记录的分配内存的大小长度    static void     BaseFree(void* p);    static void     BaseMemcpy(void* dst,const void* src, S32 size);    static void     BaseMemset(void* dst,S32 value, S32 size);        // 二维内存的分配和释放， typeSize 为数据类型所占据的内存大小， 使用  sizeof() 计算    static void*    BaseMallocXX(S32 row, S32 col, S32 typeSize);    static void     BaseFreeXX(void* _p);        // 三维内存的分配和释放， typeSize 为数据类型所占据的内存大小， 使用  sizeof() 计算    static void*    BaseMallocXXX(S32 r1, S32 r2, S32 r3, S32 typeSize);    static void     BaseFreeXXX(void* _p);        // 编码转换    static int      UTF8ToGB2312(char* _form, int _fromLen, char* _out, int _outLen);    static int      GB2312ToUTF8(char* _form, int _fromLen, char* _out, int _outLen);        // 字符串操作    static S32      BaseStrcmp(const STR* op1,const STR* op2);    static STR*     BaseStrcpy(STR* dst,const STR* src);    static STR*     BaseStrcat(STR* dst,const STR* src);    static STR*     BaseStrsub(const STR* buf,S32 begin,S32 end, STR* out);    static S32      BaseStrindexof(const STR* buf,S32 begin,STR flag);    static STR*     BaseItoc(STR* buf,S32 num);    static S32      BaseCtoi(const STR* buf);    static S32      BaseStrlen(const STR* str);    static S32      BaseStrwid(const STR* str);    static S32      BaseCharwid(STR c);        // 文件读写部分     static bool     hasFile(const char* _fileName); // (存档文件)    static int		writeFile(const char* _fileName, void* _buf, int _bufLen);    static int		readFile(const char* _fileName, void* _buf, int _bufLen);    static bool     hasResFile(const char* _fileName);  // 判断资源文件是否存在            static const char* getPath(const char* _fileName);      // 得到具体的路径名(读取资源文件用到)    static const char* getSavPath(const char* _fileName);   // 得到写文件的具体路径（写文件用到）    static const char* getFileName(const char* _fileName, const char* _suffix);  // 得到文件名称， _fileName，文件名， _suffix，后缀名    static const char* deviceId();                          // 得到当前设备的  id 数据（游戏记录绑定手机用到）            // 屏幕属性获得    static float         screenW();    static float         screenH();    static BasePoint    getPosition(BasePoint _wxvgaPos);     // 标清坐标，转换为屏幕相对坐标    static bool         posEqual(BasePoint _pos1, BasePoint _pos2);        static bool     strIsNULL(const char* _pStr);    static int      strToInt(const char* _pStr);    static float    strToFloat(const char* _pStr);       // 工具函数    static int      mathAbs( int _num );    static int      randNum( int _seed );    static int      randNum1( int _range, int _seed );    static int      randNum2( int _min, int _max, int _seed );    static long     currentTime( void );    static bool     isUnionRect(S16* r0, S16* r1);    static int      GetNumLen(int _value);          // 得到数字的位数    static void     SwapInt(int* _pNum1, int* _pNum2); // 交换两个整数            static time_t           Time(void);                 // 得到从标准计时点（一般是1970年1月1日午夜）到当前时间的秒数    // 标准时间的一些转换    static time_t           TimeToDay(time_t _time);        // _time 标准计时点，返回 标准计时点到当前时间的经过的天数    static time_t           TimeToHour(time_t _time);    static time_t           TimeToMin(time_t _time);            // 字符串过滤    static int          strFilt_NumString(const char* _numString, int* _arrOutNum, int _arrLen);    #define             StringFilt_Max	256    // 数组第二维的最大长度    static int          strFilt(const char* _pStr, char _spChar, char* _arrOut[StringFilt_Max], int _arrOutLen);    static int          strFilt2(const char* _pstr, char _spChar, char** _arrOut, int _arrOutLen);  // _arrOut 必须使用 MALLOCXX 进行动态分配， 注意防止数组的越界        // 弧度和角度之间的转换    static float        Angle2HuDu(float _angle);    static float        HuDu2Angle(float _hudu);        /*     *	角度转换， 逆时针 和顺时针直接相互转换     *  _angle, 输入参数， 如果为逆势针角度，返回顺时针角度， 如果为顺时针角度，返回逆势针角度     */    static float        AngleSwitch(float _angle);   // 逆时针角度转换为顺时针  ［0.0, 360.0］        // 角度计算    /*     *	计算两个点形成的直线的角度,取值范围在 ［0.0, 360.0］ 之间     *	注意：此函数返回的度数表示， x 轴逆时针旋转的度数， 而 sprite setRoation 方法表示 x 轴顺时针旋转的度数，用的时候，直接将此函数的结构 取反就可以了。     *		 也可以使用 ccpAngle () 计算角度数据     */    static float        AngleForLine(BasePoint _pointStart,BasePoint _pointEnd);        /*     *	通过：_startPoint, _angle, _lineLen 计算的到线段终点的坐标点     *	注意：_angle， x 轴逆时针旋转的度数     */    static BasePoint	GetLinePoint(BasePoint _startPoint,float _angle, float _lineLen);        // 求两点之间的距离    static float        GetPointDistance(BasePoint _point1, BasePoint _point2);        // 判断一个点，是否在指定的圆形区域内    static bool         PointInArea(BasePoint _point, BasePoint _centerPoint, float _radius);            // 缓冲相关    static void         SpriteCacheLoad(const char* _pListFile);    // .plist 和.png 文件名字要保持一致    static void         SpriteCacheFree(const char* _pListFile);    static void         SpriteCacheFreeUnuse();		// 释放使用的资源    static void         SpriteCacheFreeAll();    static Sprite*      SpriteCacheGetSprite(const char* _fileName);    static Animation*   SpriteCacheGetAnimation(const char* _filePrefix, int _start, int _end, float _dt);            /*     *	判定某个对象在 target 中是否是显示状态     *  _target         目标对象     *	_isShow         是否显示     *  _rect           显示区域     *  _tag            标志为信息，也用来作为 Z 轴的显示数据     *     */    static bool         IsShowInTarget(Node* _target, int _tag);      // 是否显示        /*     *	设置一个填充区域显示     *  _target         目标对象     *	_isShow         是否显示     *  _rect           显示区域     *  _tag            标志为信息，也用来作为 Z 轴的显示数据     *     */    static  void        SetFillRect(Node* _target, bool _isShow,int _tag, BaseRect _rect, float _r, float _g, float _b, float _alpha);        /*     *	判断屏幕上的某个触摸点是否在 _spr 显示范围内     *  _spr            精灵对象     *	_screenPos      为屏幕坐标     *     */    static bool         PointInSpriteFrame(Sprite* _spr, BasePoint _screenPos);           static BaseSize		GetSpriteImgSize(Sprite* _spr);     // 得到精灵图片的大小    static BaseSize		GetSpriteImgSizeInPixels(Sprite* _spr);            // 将一个对象缩放到屏幕大小,缩放是目标对象填充整个屏幕 （iphone, ipad 移植用到）    static void     ScaleToFullScreen(Node* _node, bool _isScaleX, bool _isScaleY);    static void     ScaleToFullScreenByTag(Node* _target, int _tag, bool _isScaleX, bool _isScaleY);        // 缩放成当前屏幕对应的大小比例（图片资源应该是高清资源图片）    static void     ScaleToScreenSize(Node* _node, bool _isScaleX, bool _isScaleY);    static void     ScaleToScreenSizeByTag(Node* _target, int _tag, bool _isScaleX, bool _isScaleY);                /*     *	设置，图片的显示区域百分比     *	_percent 图片显示图片显示的百分比[0.0, 1.0]     *	_dir, 从哪个方向开始显示 －－－左，右，上，下     *     *	注意： 使用此函数前，必须合理的设置 sprite 的锚点才可以。将锚点统一设置成左下角 [_sprite setAnchorPoint:BasePoint(0,0)];     *       */    static void SetSpriteDrawPercent(Sprite* _spr, float _percent, DrawPercentDir _dir);            /*     *	向 _target 中，添加一个 CCParticleSystem 粒子对象     *  _target         目标对象     *	_screenPos      为坐标     *  _pListFileName  粒子动画，对应的 plist 文件名称     *     */    static ParticleSystem*    InitParticle(Node* _target, int _tagId, const char* _pListFileName, BasePoint _pos);    };#define     MATH_PI		(3.1415926f)#define     RGB(r, g, b) (S32) (((S32)(r)<<16) | ((S32)(g) << 8) | ((S32)(b)))  //生成0xff ff ff颜色（R,G,B）#define     RGB_R(color) (S32) (((S32)color>> 16) & 0x000000ff)#define     RGB_G(color) (S32) (((S32)color>> 8) & 0x000000ff)#define     RGB_B(color) (S32) ((S32)color&0x000000ff)#define     MAX_VALUE(a,b) (((a) > (b)) ? (a) : (b))#define     MIN_VALUE(a,b) (((a) < (b)) ? (a) : (b))// 求数组的长度， 只有使用 BaseUtil::BaseMalloc 相关函数分配的内存，才可以使用次函数计算长度#define     ARRLEN(P) (S32)(P==NULL?0:(*(S32*)((S8*)P-4))/sizeof(*P))#define		ARRLEN_STATIC(arr)	(sizeof(arr)/sizeof(arr[0]))        // 求静态数组第一维长度 （例如：int arr[10], 在栈区分配）// 一维内存#define     MALLOC(n,type) (type*)BaseUtil::BaseMalloc(sizeof(type)*(n))#define     FREE(P) BaseUtil::BaseFree(P);P=NULL// 二位内存#define     MALLOCXX(row, col, type) ( (type**)BaseUtil::BaseMallocXX(row, col, sizeof(type)) )#define     FREEXX(p)	BaseUtil::BaseFreeXX((void*)p); p=NULL// 三维内存#define     MALLOCXXX(r1, r2, r3, type)  ( (type***)BaseUtil::BaseMallocXXX(r1, r2, r3, sizeof(type)) )#define     FREEXXX(p) BaseUtil::BaseFreeXXX((void*)p); p=NULL// 分配内存，将首地址交给 dest 指针, 此函数会先释放 dest 指针指向处的内存,然后在重新分配内存#define     MALLOC_TO(dst, n, type) {BaseUtil::BaseFree(dst); dst = (type*)BaseUtil::BaseMalloc(sizeof(type)*(n));}#define     MALLOCXX_TO(dst, row, col, type) {BaseUtil::BaseFreeXX(dst); dst = (type**)BaseUtil::BaseMallocXX(row, col, sizeof(type)); }#define     MALLOCXXX_TO(dst, r1, r2, r3, type) {BaseUtil::BaseFreeXXX(dst); dst = (type***)BaseUtil::BaseMallocXXX(r1, r2, r3, sizeof(type)); }#define     SCREEN_W        BaseUtil::screenW()#define     SCREEN_H        BaseUtil::screenH()#define     SCREEN_CENTER   BasePoint(BaseUtil::screenW()/2, BaseUtil::screenH()/2)#define     SCREEN_RECT     BaseRect((0), (0), (BaseUtil::screenW()), (BaseUtil::screenH()))          // 屏幕区域#define     SAFE_DELETE(obj)    {delete obj; obj = NULL;}// 给 var 增加一个 数值， 并限制增加后， var 的取值在  [min,max] 之间#define     LIMIT_ADD(var,add,min,max) { var+=add; if(var<min) var = min; if(var > max) var = max;}#endif   // __BASE_UITL_H__