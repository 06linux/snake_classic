#include "Base.h"#include "BaseStream.h"// 编码转换函数//static WSTR* UTF8toUCS2Code(U8* utf8_code, WSTR* ucs2_code)//{//	U16 temp1, temp2;//	U32 step = 1,counter = 0, end = strlen((char *)utf8_code);//	U8* utf8string = utf8_code;//	S32 index = 0;//	if(!utf8_code || !ucs2_code)//	{//		return 0;//	}//    //	while(counter < end + 1)//	{//		ucs2_code[index] = 0;//		if(0x00 == (*utf8string & 0x80))//		{//			/* 1 byte UTF-8 Charater.*///			temp1 = *((U8 *)(utf8string));//			ucs2_code[index] = temp1;//            //			// Ωªªª¥Û–°∂Œ£≠£≠∏˘æ›æﬂÃÂµƒ…Ë±∏¿¥»∑∂® «∑Ò¥Úø™//			// ucs2_code[index] = ucs2_code[index]|(temp1>>8);//			// ucs2_code[index] = ucs2_code[index]|(temp1<<8);//            //			step = 1;//			counter += step;//			utf8string += step;//		}//		else if(0xc0 == (*utf8string & 0xe0) && 0x80 == (*(utf8string + 1) & 0xc0))//		{//			/* 2 bytes UTF-8 Charater.*/ //			temp1 = (U16)(*utf8string & 0x1f);//			temp1 <<= 6;//			temp1 |= (U16)(*(utf8string + 1) & 0x3f);//			ucs2_code[index] = temp1;//			//			// Ωªªª¥Û–°∂Œ£≠£≠∏˘æ›æﬂÃÂµƒ…Ë±∏¿¥»∑∂® «∑Ò¥Úø™//			// ucs2_code[index] = ucs2_code[index]|(temp1>>8);//			// ucs2_code[index] = ucs2_code[index]|(temp1<<8);			//            //			step = 2;//			counter += step;//			utf8string += step;//		}//		else if( 0xe0 == (*utf8string & 0xf0) &&0x80 == (*(utf8string +1) & 0xc0) &&0x80 == (*(utf8string + 2) & 0xc0))//		{//			//U16 temp;//			/* 3bytes UTF-8 Charater.*///			temp1 = (U16)(*utf8string &0x0f);//			temp1 <<= 12;//			temp2 = (U16)(*(utf8string+1) & 0x3F);//			temp2 <<= 6;//			temp1 = temp1 | temp2 | (U16)(*(utf8string+2) & 0x3F);//			ucs2_code[index] = temp1;//			//			// Ωªªª¥Û–°∂Œ£≠£≠∏˘æ›æﬂÃÂµƒ…Ë±∏¿¥»∑∂® «∑Ò¥Úø™//			// ucs2_code[index] = ucs2_code[index]|(temp1>>8);//			// ucs2_code[index] = ucs2_code[index]|(temp1<<8);			//			//			step = 3;//			counter += step;//			utf8string += step;//		}//		else//		{//			temp1 = *((U8 *)(utf8string));//			ucs2_code[index] = temp1;//			//			// Ωªªª¥Û–°∂Œ£≠£≠∏˘æ›æﬂÃÂµƒ…Ë±∏¿¥»∑∂® «∑Ò¥Úø™//			// ucs2_code[index] = ucs2_code[index]|(temp1>>8);//			// ucs2_code[index] = ucs2_code[index]|(temp1<<8);			//            //			utf8string ++;//			counter ++;//		}//		index++;//	}//	ucs2_code[index] = 0;//	return ucs2_code;//}InputStream::InputStream(const char* _fileName, bool _isSaveFile){    assert(_fileName != NULL);        FILE*           fp=NULL;	int             size = 0;        if(_isSaveFile)    {        // 得到全路径名-- 存档文件        fp=fopen(BaseUtil::getSavPath(_fileName), "rb");    }    else    {        // 资源文件名称        fp=fopen(BaseUtil::getPath(_fileName), "rb");    }        if(fp==NULL)    {        return;    }            fseek(fp, 0, SEEK_END);     // 得到文件流的大小    size=ftell(fp);    fclose(fp);            // 读取文件中的所有数据    if(_isSaveFile)    {        fp=fopen(BaseUtil::getSavPath(_fileName), "rb");  // 二进制读取的方式打开    }    else    {        fp=fopen(BaseUtil::getPath(_fileName), "rb");    }            data=(U8*)malloc(size);    fread(data, size, 1,fp);    fclose(fp);            // 初始化流索引，大小    index = 0;    lenght = size;}InputStream::~InputStream(){    if(data==NULL)    {        return;    }        // 释放流数据	free(data);    data = NULL;        lenght = 0;    index = 0;    }void InputStream::skipStream(U32 _len){    index += _len;}U8  InputStream::readUByte(void){    return data[index++];}S8  InputStream::readByte(void){    return (S8)(data[index++]);}U16  InputStream::readUShort(void){    U16 temp = 0x0000;	U8 n1,n2;	n1 = data[index++];	n2 = data[index++];	temp = (temp|n1)<<8;	temp |= n2;	return temp;}S16  InputStream::readShort(void){    U16 temp = 0x0000;	U8 n1,n2;	n1 = data[index++];	n2 = data[index++];	temp = (temp|n1)<<8;	temp |= n2;	return (S16)temp;}U32  InputStream::readUInt(void){    U32 temp = 0x00000000;	U8 n1,n2,n3,n4;	n1 = data[index++];	n2 = data[index++];	n3 = data[index++];	n4 = data[index++];	temp = (temp|n1)<<8;	temp = (temp|n2)<<8;	temp = (temp|n3)<<8;	temp |= n4;	return temp;}S32  InputStream::readInt(void){    U32 temp = 0x00000000;	U8 n1,n2,n3,n4;	n1 = data[index++];	n2 = data[index++];	n3 = data[index++];	n4 = data[index++];	temp = (temp|n1)<<8;	temp = (temp|n2)<<8;	temp = (temp|n3)<<8;	temp |= n4;	return (S32)temp;}U8*  InputStream::readArray(void* array,U32 Len){    memcpy(array,&data[index],Len);	index+=Len;	return (U8*)array;}char* InputStream::readUTFByMalloc(){    int len = readUShort();    char* data = MALLOC(len+6, char);    readArray(data, len);    return data;}OutputStream::OutputStream(const char* _fileName){    assert(_fileName != NULL);        index = 0;    memset(data,0,sizeof(data));    memset(fileSavName,0,sizeof(fileSavName));            // 存储文件名称	strcpy(fileSavName, _fileName);    }OutputStream::~OutputStream(){    const char* filePathName = BaseUtil::getSavPath(fileSavName);    FILE* file = fopen(filePathName,"wb");    // 二进制写的方式打开 , 注意路径名称	if(file!=NULL)	{		fwrite(data,index,1,file);		fclose(file);	}}void OutputStream::writeUByte(U8 value){    data[index++] = value;}void OutputStream::writeByte(S8 value){    data[index++] = (U8)value;}void OutputStream::writeUShort(U16 value){    U8 n1 = (value>>8)&0x00ff;	U8 n2 = value&0x00ff;	data[index++] = n1;	data[index++] = n2;}void OutputStream::writeShort(S16 value){    U8 n1 = (((U16)value)>>8)&0x00ff;	U8 n2 = ((U16)value)&0x00ff;	data[index++] = n1;	data[index++] = n2;}void OutputStream::writeUInt(U32 value){    U8 n1 = (value>>24)&0x000000ff;	U8 n2 = (value>>16)&0x000000ff;	U8 n3 = (value>>8)&0x000000ff;	U8 n4 = value&0x000000ff;	data[index++] = n1;	data[index++] = n2;	data[index++] = n3;	data[index++] = n4;}void OutputStream::writeInt(S32 value){    U32 temp = (U32)value;	U8 n1 = (temp>>24)&0x000000ff;	U8 n2 = (temp>>16)&0x000000ff;	U8 n3 = (temp>>8)&0x000000ff;	U8 n4 = temp&0x000000ff;	data[index++] = n1;	data[index++] = n2;	data[index++] = n3;	data[index++] = n4;}void OutputStream::writeArray(void* value,U32 Len){    memcpy(&data[index],value,Len);	index+=Len;}