#include "Base.h"#include "BaseUtil.h"#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <iconv.h>#include <sys/time.h>#include <iconv.h> void* BaseUtil::BaseMalloc(S32 size){    void* p = NULL;	if(size<=0)return NULL;	p = malloc(size+4);	if(p==NULL) return NULL;	memset(p,0,size+4);	*((S32*)p) = (S32)size;	return (void*)((S8*)p+4);    }void BaseUtil::BaseFree(void* p){    void* temp = NULL;	S32 size = 0;	if(p==NULL)return;	temp = (void*)((S8*)p-4);	size = *((S32*)temp);	free(temp);}void  BaseUtil::BaseMemcpy(void* dst,const void* src, S32 size){    memcpy(dst,src,size);}void  BaseUtil::BaseMemset(void* dst,S32 value, S32 size){    memset(dst,value,size);}/* *	函数描述：	二维数据内存的申请 *	参数：		row， 行 *				col, 列 *				typeSize，表示基本数据类型的大小，可以用 sizeof() 计算 *				 *	返回值：      void  *	备注：		无  * */void* BaseUtil::BaseMallocXX(S32 row, S32 col, S32 typeSize){    S32 i; 	S32** p = (S32**)BaseUtil::BaseMalloc(row*sizeof(S32*));  // 指针的大小始终为4 	 	for(i=0; i<row; i++)		// 为每一行分配内存 	{ 		p[i] = (S32*)BaseUtil::BaseMalloc(typeSize*col);  	}		return (void*)p;}/* *	函数描述：	二维数据内存的释放 *	参数：		p, 二维指针的首地址  *				 *	返回值：      void  *	备注：		无  * */void  BaseUtil::BaseFreeXX(void* _p){    S32 i;	S32** p = (S32**) _p;	S32 rowLen = ARRLEN(p);		// 先释放每一行的内存，最后释放自己	for(i=0; i< rowLen; i++)	{		BaseUtil::BaseFree((void*)p[i]); 		p[i] = NULL;	}		BaseUtil::BaseFree(p);    }// 三维数据内存的申请, r1, 第一维（行）， r2 第二维, r3 第三维void* BaseUtil::BaseMallocXXX(S32 r1, S32 r2, S32 r3, S32 typeSize){    S32 i,j;	S32*** p = (S32***)BaseUtil::BaseMalloc(r1*sizeof(S32**));  // 指针的大小始终为4 		for(i=0; i<r1; i++)		// 为每一行分配内存	{		p[i] = (S32**)BaseUtil::BaseMalloc(r2*sizeof(S32*));		for(j=0; j< r2; j++)		{			p[i][j] = (S32*)BaseUtil::BaseMalloc(typeSize* r3); 		}	}		return (void*)p;}// 三位数据内存释放void  BaseUtil::BaseFreeXXX(void* _p){    S32 i, j;	S32 r1Len, r2Len;	S32*** p = (S32***) _p;		r1Len = ARRLEN(p);	for(i=0; i<r1Len; i++)	{		r2Len = ARRLEN(p[i]);		for(j=0; j<r2Len; j++)		{			BaseUtil::BaseFree((void*)p[i][j]); 			p[i][j] = NULL;		}		BaseUtil::BaseFree((void*)p[i]);		p[i] = NULL;	}	BaseUtil::BaseFree(p);}/* *  函数说明:  写文件函数 *  参数描述:  _fileName, 文件名称 *			  _buf, 要写的内存缓冲。 *			  _bufLen, 内存缓冲的长度 *  返回值:    0,  成功 *			  -1, 失败 *	备注信息:  GetSavPath, 用来得到保存文件的路径名称信息，iphone 读写有沙合限制，只能读写本应用目录下面的文件。 * */int BaseUtil::writeFile(const char* _fileName, void* _buf, int _bufLen){	FILE * fp = NULL;	if( NULL == _buf || _bufLen <= 0 ) return (-1);		const char *fullpath = BaseUtil::getSavPath(_fileName);	fp = fopen(fullpath, "wb");  // 只写的方式打开	if( NULL == fp )	{		return (-1);	}		fwrite(_buf, _bufLen, 1, fp);  //二进制写	fclose(fp);	fp = NULL;		return 0;	}/* *  函数说明:  读文件函数 *  参数描述:  _fileName, 文件名称 *			  _buf, 读出来的数据存放位置 *			  _bufLen, 数据的长度信息 *  返回值:    0,  成功 *			  -1, 失败 *	备注信息:  GetSavPath, 用来得到保存文件的路径名称信息，iphone 读写有沙合限制，只能读写本应用目录下面的文件。 * */int BaseUtil::readFile(const char* _fileName, void* _buf, int _bufLen){	FILE* fp = NULL;	if( NULL == _buf || _bufLen <= 0 ) return (-1);		const char *fullpath = BaseUtil::getSavPath(_fileName);	fp = fopen(fullpath, "rb");  // 只读方式打开	if( NULL == fp )	{		return (-1);	}		fread(_buf, _bufLen, 1, fp);  // 二进制读	fclose(fp);	return 0;		}/* *  函数说明:  检测文件是否存在 *  参数描述:  _fileName, 文件名称 *  返回值:    true,  文件存在 *			  true,  文件不存在 *	备注信息:  GetSavPath, 用来得到保存文件的路径名称信息，iphone 读写有沙合限制，只能读写本应用目录下面的文件。 * */bool BaseUtil::hasFile(const char* _fileName){	FILE* fp = NULL;	const char *fullpath = BaseUtil::getSavPath(_fileName);	fp = fopen(fullpath, "rb");  // 只读方式打开	if( NULL == fp )	{		return false;	}		fclose(fp);	return true;	}//检查对应的资源文件是否存在bool   BaseUtil::hasResFile(const char* _fileName){    const char*   filePathName = BaseUtil::getPath(_fileName);    return access(filePathName, 0)==0;}const char* BaseUtil::getPath(const char* _fileName){    return CCFileUtils::getInstance()->fullPathForFilename(_fileName).c_str();}// 得到写文件的具体路径（写文件用到）static char gSavPathName[1024] = "";   // 路径长度最多支持  1024 个长度const char* BaseUtil::getSavPath(const char* _fileName) {    memset(gSavPathName, 0, sizeof(gSavPathName));    strcpy(gSavPathName, CCFileUtils::getInstance()->getWritablePath().c_str());    strcat(gSavPathName, _fileName);    return gSavPathName;}static char gDiviceId[512] = "";const char* BaseUtil::deviceId(){    memset(gDiviceId, 0, sizeof(gDiviceId));//    getIosDeviceId(gDiviceId, sizeof(gDiviceId));    return gDiviceId;}static char gFileName[512] = "";    // 长度最多支持 512 个字符const char* BaseUtil::getFileName(const char* _fileName, const char* _suffix){    if(!BaseUtil::strIsNULL(_fileName) && !BaseUtil::strIsNULL(_suffix))    {        memset(gFileName, 0, sizeof(gFileName));        strcpy(gFileName, _fileName);        strcat(gFileName, _suffix);                return gFileName;    }        return NULL;}/* *  函数说明:  求一个数的绝对值 *  参数描述:  _num, 整数 *  返回值:     返回一个整数的绝对值 *	备注信息:  无 * */int BaseUtil::mathAbs( int _num ){	if( _num < 0 )	{		return (0-_num);	}		return _num;}/* *  函数说明:  得到一个随机数 *  参数描述:  _seed, 随机数的种子 *  返回值:    随机数 *	备注信息:  无 * */int BaseUtil::randNum( int _seed ){	//srand((int)BaseUtil::currentTime()*10000 + _seed);  // 设置种子	return (arc4random());}/* *  函数说明:  得到一个随机数 *  参数描述:  _range, 取值范围 ［0，_rang-1］ *			 _seed, 随机数的种子 *  返回值:    随机数 *	备注信息:  无 * */int BaseUtil::randNum1( int _range, int _seed ){	if( _range <= 0 )	{		return 0;	}		//srand((int)BaseUtil::currentTime()*10000+_seed);  // 设置种子	return BaseUtil::mathAbs(arc4random())%_range;}/* *  函数说明:  得到一个随机数 *  参数描述:  _min,_max 取值范围 [_min, _max] *			 _seed, 随机数的种子 *  返回值:    随机数 *	备注信息:  无 * */int BaseUtil::randNum2( int _min, int _max, int _seed ){	if( _min <= 0  || _max <= 0 )	{		return 0;	}		return _min + BaseUtil::randNum1(_max-_min+1, _seed);}/* *  函数说明:  得到当前系统的时间--微妙 *  参数描述:  void *  返回值:    当前的时间, 一个估计值,相对值,用于真机调试的  *	备注信息:  此函数在真机环境调试的时候使用 * */long BaseUtil::currentTime( void ){	struct timeval temp_tv;	struct timezone temp_tz;	gettimeofday(&temp_tv, &temp_tz);	//return (temp_tv.tv_sec%60)*1000 + temp_tv.tv_usec%1000;	return temp_tv.tv_usec;}float BaseUtil::screenW(){	return CCDirector::getInstance()->getWinSize().width;}float BaseUtil::screenH(){	return CCDirector::getInstance()->getWinSize().height;}// _wxvgaPos 为 480，320 屏幕坐标系统中的绝对坐标// 建议ui 布局统一使用绝对坐标BasePoint  BaseUtil::getPosition(BasePoint _wxvgaPos){#ifdef GAME_DEV_Landscape    return BasePoint(SCREEN_W*(_wxvgaPos.x/480.0), SCREEN_H*(_wxvgaPos.y/320.0));  // 横屏幕#endif        // 竖屏幕    return BasePoint(SCREEN_W*(_wxvgaPos.x/320.0), SCREEN_H*(_wxvgaPos.y/480.0));}bool BaseUtil::posEqual(BasePoint _pos1, BasePoint _pos2){    if(_pos1.x == _pos2.x && _pos1.y == _pos2.y)	{		return true;	}		return false;}/* *	函数描述：	计算两区域的公共区域 *	参数：		r0(short[]:In):第一个区域(左上，右下坐标) *				r1(short[]:In,Out):第二个区域(左上，右下坐标)，两区域的公共区域也会存放在其中 *				 *	返回值：		(boolean:Out):区域是否存在公共区域 * */bool BaseUtil::isUnionRect(S16* r0, S16* r1){	if( NULL == r0 || NULL == r1) return false;		if(r0[2]>r1[0]&&r0[0]<r1[2]&&r0[3]>r1[1]&&r0[1]<r1[3])	{		return true;	}	return false;}// 字符串操作S32	BaseUtil::BaseStrcmp(const STR* op1,const STR* op2){	S32 op1Len = BaseUtil::BaseStrlen(op1);	S32 op2Len = BaseUtil::BaseStrlen(op2);	if(op1Len!=op2Len)return -1;	return memcmp(op1,op2,op1Len);}STR* BaseUtil::BaseStrcpy(STR* dst,const STR* src){	S32 srcLen = BaseUtil::BaseStrlen(src);	memcpy(dst,src,sizeof(STR)*srcLen);	dst[srcLen] = 0;	return dst;}STR* BaseUtil::BaseStrcat(STR* dst,const STR* src){	S32 dstLen = BaseUtil::BaseStrlen(dst);	S32 srcLen = BaseUtil::BaseStrlen(src);	memcpy(&dst[dstLen],src,sizeof(STR)*srcLen);	dst[dstLen+srcLen] = 0;	return dst;}STR* BaseUtil::BaseStrsub(const STR* buf,S32 begin,S32 end, STR* out){	memcpy(out,&buf[begin],sizeof(STR)*(end-begin));	out[end-begin] = 0;	return out;}S32	BaseUtil::BaseStrindexof(const STR* buf,S32 begin,STR flag){	S32 i,Len = BaseUtil::BaseStrlen(buf);	if(begin>=Len)return -1;	for(i=begin;i<Len;i++)	{		if(buf[i]==flag)return i;	}	return -1;}STR*  BaseUtil::BaseItoc(STR* buf,S32 num){	S32 i;	S32 shu_num;	S32 charNums = 0;	if(buf==NULL)return NULL;	shu_num = num;	for(i=0;i<9;i++)	{		charNums++;		shu_num = shu_num/10;		if( shu_num == 0 )			break;	}	shu_num = num;	for(i=1;i<=charNums;i++)	{		buf[charNums-i] = (shu_num - (shu_num/10)*10) + 0x30;		shu_num = shu_num/10;	}	buf[charNums] = 0;	return buf;}S32	BaseUtil::BaseCtoi(const STR* buf){	S32 len = BaseUtil::BaseStrlen(buf);	S32 num = 0,i;	for (i=0;i<len;i++)	{		num *= 10;		num += buf[i]-0x0030;	}	return num;	}S32	BaseUtil::BaseStrlen(const STR* str){	S32 i=0;	if(str==NULL)return 0;	while (true)	{		if(str[i]==0)break;		i++;	}	return i;}S32	BaseUtil::BaseStrwid(const STR* str){	if(str==NULL)return 0;	return 12*BaseUtil::BaseStrlen(str);}S32	BaseUtil::BaseCharwid(STR c){	return 12;}bool BaseUtil::strIsNULL(const char* _pStr){	if(NULL == _pStr) return true;		if( 0 == strcmp(_pStr, "null") ||        0 == strcmp(_pStr, "Null") ||        0 == strcmp(_pStr, "NULL") ||       0 == strlen(_pStr)	   )	{		return true;	}		return false;}int BaseUtil::strToInt(const char* _pStr){    if(BaseUtil::strIsNULL(_pStr))    {        return 0;    }		return atoi(_pStr);}float BaseUtil::strToFloat(const char* _pStr){    if(BaseUtil::strIsNULL(_pStr))    {        return 0;    }		return atof(_pStr);}/* *	过滤数字字符串， 将 “1,2,3,4,5,6” 这种形式的字符串过滤到 _arrOutNum 数组中 *	返回： _arrOutNum 数组中有效元素的个数 * *	使用举例： *				int arrNum[16] = {0}; *				int ret = BaseUtil::StringFilt_NumString("12,567,1,23,456,7890,123,000,123,arrNum,16); * */int BaseUtil::strFilt_NumString(const char* _numString, int* _arrOutNum,int _arrLen){    int retArrLen = 0;		if(_numString && _arrOutNum)	{		const char* cString = _numString;		unsigned int strLen = strlen(_numString);				for(unsigned int i=0; i<strLen; i++)		{			if(retArrLen >= _arrLen) break;						char szNum[32] = {0};  			int	szNumLen = 0;			for(unsigned int j = 0; j< sizeof(szNum)/sizeof(szNum[0]); j++ )			{				if(i+j<strLen && cString[i+j] >='0' &&  cString[i+j] <= '9')     // 只过滤 0到 9 的数字				{					szNum[j] = cString[i+j];					szNumLen++;										continue;				}								if(szNumLen > 0)				{					_arrOutNum[retArrLen++] = atoi(szNum);				}								i+=j;				break;			}		}	}		return retArrLen;}/* *	"," 分隔过滤英文字符串， 将 “aaa,bbb,ccc,ddd,fff,eee” 这种形式的字符串过滤到 _arrArr 数组中 *	返回： _arrChar 数组中有效元素的个数 *	注意： (char**) _arrChar 防止数组越界	 * *	使用举例： *			char  arr[10][StringFilt_Max] = {""}; *			int arrUseLen = 0; *			arrUseLen = BaseUtil::StringFilt("hello, world,this my first,test",arr ,sizeof(arr)/sizeof(arr[0])); * * */int BaseUtil::strFilt(const char* _pStr, char _spChar, char* _arrOut[StringFilt_Max], int _arrOutLen){    int retArrLen = 0;		if(_pStr)	{		const char* cString = _pStr;		unsigned int strLen = strlen(_pStr);				int index = 0;  				for(unsigned int i=0; i<strLen; i++)		{			if(retArrLen >= _arrOutLen) break;						if( _spChar == cString[i] )  // _spChar 分隔			{				_arrOut[retArrLen][index++] = '\0';   // 上一行数据结束								retArrLen++;				index = 0;				continue;			}						_arrOut[retArrLen][index++] = cString[i];					}				_arrOut[retArrLen][index++] = '\0';   // 上一行数据结束				//  "xx,xx,xx" 分隔的个数等于 , 的个数  ＋1 		// "," 这种情况，认为 , 左右的数据都是 null, 照样返回两个空的数据		if(retArrLen < _arrOutLen)		{			retArrLen +=1;				}			}		return retArrLen;}// _arrOut 必须使用 MALLOCXX 进行动态分配， 注意防止数组的越界int BaseUtil::strFilt2(const char* _pStr, char _spChar, char** _arrOut, int _arrOutLen){    int retArrLen = 0;		if(_pStr)	{		const char* cString = _pStr;		unsigned int strLen = strlen(_pStr);				int index = 0;  				for(unsigned int i=0; i<strLen; i++)		{			if(retArrLen >= _arrOutLen) break;						if( _spChar == cString[i] )  // _spChar 分隔			{				retArrLen++;				index = 0;				continue;			}						_arrOut[retArrLen][index++] = cString[i];					}						//  "xx,xx,xx" 分隔的个数等于 , 的个数  ＋1 		// "," 这种情况，认为 , 左右的数据都是 null, 照样返回两个空的数据		if(retArrLen < _arrOutLen)		{			retArrLen +=1;				}			}		return retArrLen;}float BaseUtil::Angle2HuDu(float _angle){    float ret = (_angle/180.f)* MATH_PI;	return ret;}float BaseUtil::HuDu2Angle(float _hudu){    float ret = (_hudu/MATH_PI)*180.0f; 	return ret;}float BaseUtil::AngleSwitch(float _angle){    float retAngle = 0;	if(_angle >=0 && _angle < 360)	{		retAngle = 360 - _angle;	}		return retAngle;}float BaseUtil::AngleForLine(BasePoint _pointStart,BasePoint _pointEnd){    float xLen = BaseUtil::mathAbs(_pointStart.x - _pointEnd.x);	float yLen = BaseUtil::mathAbs(_pointStart.y - _pointEnd.y);	float retAngle = 0;		if(xLen == 0 && yLen == 0 )	{		retAngle = 0;		return retAngle;	}		if(xLen == 0)  // x 方向上位置相同	{		if(_pointStart.y < _pointEnd.y )		{			retAngle = 90.0;		}		else		{			retAngle = 270.0;		}        		return retAngle;	}		if(yLen == 0) // y 方向上位置相同	{		if(_pointStart.x < _pointEnd.x )		{			retAngle = 0;		}		else		{			retAngle = 180;		}        		return retAngle;	}			float hudu = atanf(yLen/xLen);	retAngle = (hudu/MATH_PI)*180;  		if(_pointStart.x < _pointEnd.x )	{		if(_pointStart.y < _pointEnd.y )		{			// 正常计算的角度		}		else		{			retAngle = 360 - retAngle;		}	}	else	{		if(_pointStart.y < _pointEnd.y )		{			retAngle = 180 - retAngle;		}		else		{			retAngle = 180 + retAngle;		}	}    	return retAngle;}BasePoint	BaseUtil::GetLinePoint(BasePoint _startPoint,float _angle, float _lineLen){   	if(_lineLen< 0) 	{		return _startPoint;	}		float  hudu = BaseUtil::Angle2HuDu(_angle);		float offX =  _lineLen*cosf(hudu);	float offY = _lineLen*sinf(hudu);		BasePoint retPoint = BasePoint(0, 0);		retPoint.x = _startPoint.x + offX;	retPoint.y = _startPoint.y + offY;		return retPoint;     }float  BaseUtil::GetPointDistance(BasePoint _point1, BasePoint _point2){    return _point1.getDistance(_point2);}bool BaseUtil::PointInArea(BasePoint _point, BasePoint _centerPoint, float _radius){    float xLen = BaseUtil::mathAbs(_point.x - _centerPoint.x);	float yLen = BaseUtil::mathAbs(_point.y - _centerPoint.y);	float distance = sqrtf(xLen*xLen + yLen*yLen);		if(distance < _radius)	{		return true;	}		return false;}void BaseUtil::SpriteCacheLoad(const char* _pListFile){    CCSpriteFrameCache::getInstance()->addSpriteFramesWithFile(_pListFile);}void BaseUtil::SpriteCacheFree(const char* _pListFile){    CCSpriteFrameCache::getInstance()->removeSpriteFramesFromFile(_pListFile);}void BaseUtil::SpriteCacheFreeUnuse(){     CCSpriteFrameCache::getInstance()->removeUnusedSpriteFrames();}void BaseUtil::SpriteCacheFreeAll(){    CCSpriteFrameCache::getInstance()->removeSpriteFrames();}Sprite* BaseUtil::SpriteCacheGetSprite(const char* _fileName){    Sprite* retSprite = NULL;	SpriteFrame* frame  = CCSpriteFrameCache::getInstance()->getSpriteFrameByName(_fileName);		if(frame)  // 必须确保 frame 是存在的	{		retSprite = CCSprite::createWithSpriteFrame(frame);    	}    	return retSprite;}Animation* BaseUtil::SpriteCacheGetAnimation(const char* _filePrefix, int _start, int _end, float _dt){    Animation* animation = Animation::create();  // autorelease       animation->setDelayPerUnit(_dt);        // 设置播放间隔        // 必须提前加载  plist  数据资源    BaseUtil::SpriteCacheLoad(BaseUtil::getFileName(_filePrefix, ".plist"));        if(_start <= _end )  // 需要小到大    {        for(int i= _start; i<=_end; i++)        {            char fileName[512] = "";            strcpy(fileName, _filePrefix);                        sprintf(fileName,"%s_%d.png", _filePrefix, i);            SpriteFrame* frame  = CCSpriteFrameCache::getInstance()->getSpriteFrameByName(fileName);            if(frame)            {                animation->addSpriteFrame(frame);            }        }    }    else    {        for(int i= _start; i>=_end; i--)        {            char fileName[512] = "";            strcpy(fileName, _filePrefix);                        sprintf(fileName,"%s%d.png", _filePrefix, i);            SpriteFrame* frame  = CCSpriteFrameCache::getInstance()->getSpriteFrameByName(fileName);            if(frame)            {                animation->addSpriteFrame(frame);            }        }    }            // 释放 plist  数据资源    BaseUtil::SpriteCacheFree(BaseUtil::getFileName(_filePrefix, ".plist"));		return animation;}bool BaseUtil::PointInSpriteFrame(Sprite* _spr, BasePoint _screenPos){    bool retResult = false;        if(_spr)    {        BasePoint touchPos = _screenPos;                if(_spr->getParent())        {            touchPos = _spr->getParent()->convertToNodeSpace(_screenPos);  // 转换为父亲对象中的相对坐标        }                BasePoint     positon_Spr = _spr->getPosition();        BasePoint     anchor_Spr = _spr->getAnchorPoint();        float       scaleX_Spr = _spr->getScaleX();        float       scaleY_Spr = _spr->getScaleY();        BaseRect      textureRect_Spr = _spr->getTextureRect();                        BaseRect rect = BaseRect(   positon_Spr.x - textureRect_Spr.size.width*anchor_Spr.x*scaleX_Spr,                                 positon_Spr.y -  textureRect_Spr.size.height*anchor_Spr.y*scaleY_Spr,                                 textureRect_Spr.size.width*scaleX_Spr,                                  textureRect_Spr.size.height*scaleY_Spr);                if(rect.containsPoint(touchPos))        {            retResult = true;        }    }            return retResult;}bool BaseUtil::IsShowInTarget(Node* _target, int _tag){    bool retResult = false;        if(_target)    {        Node* obj = _target->getChildByTag(_tag);        if(obj && obj->isVisible())        {            retResult = true;        }    }        return retResult;}BaseSize	BaseUtil::GetSpriteImgSize(Sprite* _spr){    BaseSize retSize = BaseSize(0, 0);        if(_spr)    {        retSize = _spr->getTexture()->getContentSize();    }    return retSize;}BaseSize	BaseUtil::GetSpriteImgSizeInPixels(Sprite* _spr){    BaseSize retSize = BaseSize(0, 0);        if(_spr)    {        retSize = _spr->getTexture()->getContentSizeInPixels();    }    return retSize;}void BaseUtil::SetSpriteDrawPercent(Sprite* _spr, float _percent, DrawPercentDir _dir){    if(NULL == _spr) return;        BaseRect imgRect;    BaseSize imgSize;        _spr->setAnchorPoint(BasePoint(0,0));     // 统一设置左下角为锚点坐标        imgSize = BaseUtil::GetSpriteImgSize(_spr);    if(imgSize.width <=0 || imgSize.height <= 0)    {        return;    }        switch (_dir)    {        case DrawPercentDir_Up:        {            float currHeight = imgSize.height*_percent;						imgRect.origin.x = 0;			imgRect.origin.y = 0;			imgRect.size.height = currHeight;			imgRect.size.width = imgSize.width;			            _spr->setTextureRect(imgRect);        }            break;        case DrawPercentDir_Down:        {            float currHeight = imgSize.height*_percent;						imgRect.origin.x = 0;			imgRect.origin.y = imgSize.height-currHeight;			imgRect.size.height = currHeight;			imgRect.size.width = imgSize.width;						_spr->setTextureRect(imgRect);        }            break;        case DrawPercentDir_Left:        {            float currWidth = imgSize.width*_percent;						imgRect.origin.x = 0;			imgRect.origin.y = 0;			imgRect.size.height = imgSize.height;			imgRect.size.width = currWidth;						_spr->setTextureRect(imgRect);        }            break;        case DrawPercentDir_Right:        {            float currWidth = imgSize.width*_percent;						imgRect.origin.x = imgSize.width - currWidth;			imgRect.origin.y = 0;			imgRect.size.height = imgSize.height;			imgRect.size.width = currWidth;						_spr->setTextureRect(imgRect);        }            break;        default:            break;    }}void  BaseUtil::ScaleToFullScreen(Node* _node, bool _isScaleX, bool _isScaleY){    if(NULL == _node) return;        BaseSize  size = _node->getContentSize();        if(_isScaleX)    {        if(size.width > 0 && SCREEN_W > 0)        {            float   scaleX = 1.0f/(float)(size.width/SCREEN_W);            _node->setScaleX(scaleX);        }    }        if(_isScaleY)    {        if(size.height > 0 && SCREEN_H > 0)        {            float scaleY = 1.0f/(float)(size.height/SCREEN_H);            _node->setScaleY(scaleY);        }    }}void BaseUtil::ScaleToFullScreenByTag(Node* _target, int _tag, bool _isScaleX, bool _isScaleY){    if(_target)    {        Node* obj = _target->getChildByTag(_tag);        if(obj)        {            BaseUtil::ScaleToFullScreen(obj, _isScaleX, _isScaleY);        }    }}void BaseUtil::ScaleToScreenSize(Node* _node, bool _isScaleX, bool _isScaleY){    if(NULL == _node) return;    if(DISP_RETINA == gDisplayMode || DISP_WXVGA == gDisplayMode) return; // 不需要处理        BaseSize   baseSize = BaseSize(640, 960);       //  必须高清图片        #ifdef GAME_DEV_Landscape       // 横屏        baseSize = BaseSizeMake(960, 640);#endif        BaseSize   size = _node->getContentSize();    if(_isScaleX)    {        if(size.width > 0 && SCREEN_W > 0)        {            float temp1 = (float)(baseSize.width/SCREEN_W);            float   scaleX = 1.0f/temp1;            _node->setScaleX(scaleX);        }    }        if(_isScaleY)    {        if(size.height > 0 && SCREEN_H > 0)        {            float scaleY = 1.0f/(float)(baseSize.height/SCREEN_H);            _node->setScaleY(scaleY);        }    }}void BaseUtil::ScaleToScreenSizeByTag(Node* _target, int _tag, bool _isScaleX, bool _isScaleY){    if(_target)    {        Node* obj = _target->getChildByTag(_tag);        if(obj)        {            BaseUtil::ScaleToScreenSize(obj, _isScaleX, _isScaleY);        }    }}ParticleSystem* BaseUtil::InitParticle(Node* _target, int _tagId, const char* _pListFileName, BasePoint _pos){    if(NULL == _target) return NULL;    if(NULL == _pListFileName) return NULL;        ParticleSystem* retObj = NULL;    ParticleSystem* obj = NULL;        // 先释放    _target->removeChildByTag(_tagId, true);            retObj = obj = CCParticleSystemQuad::create(_pListFileName);    if(obj)    {        obj->setPosition(_pos);        _target->addChild(obj, _tagId, _tagId);    }        return retObj;}int BaseUtil::GetNumLen(int _value){    int retLen = 0;     // 数字的位数    int numTemp = _value;        // 防止负数出现    if(numTemp < 0)    {        numTemp = 0 - numTemp;    }        for(int i=0; i< 100; i++)       // 最多支持 100 位数字    {        if( numTemp <= 0)        {            break;        }                retLen++;        numTemp = numTemp / 10;    }        return retLen;}void BaseUtil::SwapInt(int* _pNum1, int* _pNum2){    if(NULL == _pNum1) return;    if(NULL == _pNum2) return;        int temp = *_pNum1;    *_pNum1 = *_pNum2;    *_pNum2 = temp;}// 精确到秒time_t  BaseUtil::Time(void){    return time(NULL);}#define TIME_LEN_DAY        (24*60*60)                // 一天时间长度#define TIME_LEN_HOUR       (60*60)                   // 一个小时#define TIME_LEN_MINUTE     (60)                      // 一分钟time_t BaseUtil::TimeToDay(time_t _time){    return (_time/TIME_LEN_DAY);}time_t BaseUtil::TimeToHour(time_t _time){    return (_time/TIME_LEN_HOUR);}time_t BaseUtil::TimeToMin(time_t _time){    return (_time/TIME_LEN_MINUTE);}//代码转换:从一种编码转为另一种编码static int base_code_convert(const char *from_charset,const char *to_charset,char *inbuf,size_t inlen,char *outbuf,size_t outlen){//    iconv_t cd;//    char **pin = &inbuf;//    char **pout = &outbuf;//    //    cd = iconv_open(to_charset,from_charset);//    if (cd==0)//    {//        return -1;//    }//    memset(outbuf,0,outlen);//    if (iconv(cd,pin,&inlen,pout,&outlen)==-1)//    {//        return -1;//    }//    //    iconv_close(cd);    return 0;}int BaseUtil::UTF8ToGB2312(char* _form, int _fromLen, char* _out, int _outLen){    return base_code_convert("utf-8","gb2312",_form,_fromLen,_out,_outLen);}int BaseUtil::GB2312ToUTF8(char* _form, int _fromLen, char* _out, int _outLen){    return base_code_convert("gb2312","utf-8",_form,_fromLen,_out,_outLen);}