/* *  BaseStream.h *  CCGame * *  Created by linux_wuliqiang@163.com on 2015-03-30. *  Copyright 2015 Beijing. All rights reserved. * *	流文件读写的封装 * *  备注： *          打开文件的时候，注意文件路径问题 *          跨平台移植，使用 CCFileUtils 相关工具函数得到文件的路径数据 * */#ifndef __BASE_STREAM_H__#define __BASE_STREAM_H__typedef enum _DT_STREAM{	DT_STRING = 0,	DT_INT,	DT_SHORT,	DT_BYTE,	DT_BOOLEAN	}DT_STREAM;class InputStream{    public:     // 构造析构函数    InputStream(const char* _fileName, bool _isSaveFile);        // 是否是读取存档文件    ~InputStream();public:     // 读流        void    skipStream(U32 _len);      //  跳过指定长度        U8      readUByte(void);					    S8      readByte(void);						    U16     readUShort(void);					    S16     readShort(void);					    U32     readUInt(void);						    S32     readInt(void);						    U8*     readArray(void* array,U32 Len);          char*   readUTFByMalloc();      // 读取一个 Utf 字符串,返回一个 Malloc 的内存，在外部负责内存的释放    private:        U8*     data;       // 流数据	U32     lenght;     // 数据长度 	U32     index;      // 读取索引};#define MAX_FILENAME_LEN	(1024)				// 文件路径名最大长度#define MAX_DATA_LEN		(1024*1024*2)		// 流文件数据文件最大长度class OutputStream{    public:     // 构造析构函数    OutputStream(const char* _fileName);        // _fileName 直接写文件名称就可以    ~OutputStream();    public:     // 写流        void    writeUByte(U8 value);				    void    writeByte(S8 value);				    void    writeUShort(U16 value);                 void    writeShort(S16 value);				    void    writeUInt(U32 value);				    void    writeInt(S32 value);				    void    writeArray(void* value,U32 Len);	    private:        U8      data[MAX_DATA_LEN];                     // 需要输出的裸数据	U32     index;                                  // 数据索引	char    fileSavName[MAX_FILENAME_LEN];			// 数据存档文件名，用于最终的文件保存    };#endif //__BASE_STREAM_H__