/* *  BaseLayer.h *  CCGame * *  Created by linux_wuliqiang@163.com on 2015-03-30. *  Copyright 2015 Beijing. All rights reserved. * * * */#ifndef __BaseLayer_H__#define __BaseLayer_H__using namespace cocos2d;class BaseLayer  : public Layer{public:    CREATE_FUNC(BaseLayer);        BaseLayer();    virtual ~BaseLayer();       protected:        EventListenerTouchOneByOne*     _touchListener;         // 屏幕触摸事件监听        EventListenerKeyboard*          _keyboardListener;      // 键盘事件监听（android 下返回健，和菜单键）public:            virtual bool    onTouchBegan(Touch* _touch, Event* _event);                        // 触摸按下(回调函数)        virtual void    onTouchEnded(Touch* _touch, Event* _event);                        // 触摸抬起(回调函数)        virtual void    onTouchCancelled(Touch* _touch, Event* _event);                    // 触摸取消(回调函数)        virtual void    onTouchMoved(Touch* _touch, Event* _event);                        // 触摸移动(回调函数)        void            setTouchListener(bool _isEnableTouch, int _priority = 1);          // 是否接收触摸事件（当前layer是否接收触摸事件）, _priority 优先级        Vec2            getTouch(Touch* _touch, Event* _event);        Vec2            getTouch_Previous(Touch* _touch, Event* _event);            virtual void    onKeyPressed(EventKeyboard::KeyCode _code, Event* _event);          // (回调函数)        virtual void    onKeyReleased(EventKeyboard::KeyCode _code, Event* _event);         // (回调函数)        void            setKeyboardListener(int _priority = 2);                             // 是否接收按键事件                bool            isTouchOnNode(Node* _objNode, BasePoint _screenPos);               // 判定屏幕触摸是否在某个 ui节点之上 （此 UI 节点必须有命名为 size pannel的对象）        public: // ui 相关的函数封装        static const int UI_ACTION_TAG = 1000;        // _fileName, 带后缀文件名的文件名称，例如： test.csb    Node*           uiLoad(int _tag, const std::string& _csbFileName, Vec2 _pos);    void            uiFree(int _tag);        Node*           uiGet(int _tag);    Node*           uiGetChild(int _tag, const std::string& _childName);        // 播放指定名称的动画    void            uiPlay(Node* _objUI, const std::string& _animation);    void            uiPlay(Node* _objUI, const std::string& _animation, bool _loop);    void            uiPlay(Node* _objUI, const std::string& _animation, bool _loop, bool _isLastFrameCall, const std::string& _varStr);        // 备注：帧事件使用的时候，在编辑器里面，必须选中 “自动记录帧” 选项,否则回调函数会无效    void            uiPlayFrameEvent(Node* _objUI, const std::string& _animation, bool _loop, const std::string& _varStr);        // 从指定的帧开始播放    void            uiGotoFrameAndPlay(Node* _objUI, int _startIndex);    void            uiGotoFrameAndPlay(Node* _objUI, int _startIndex, bool _loop, bool _isLastFrameCall, const std::string& _varStr);    void            uiGotoFrameAndPlay(Node* _objUI, int _startIndex, int _endIndex, bool _loop);    void            uiGotoFrameAndPlay(Node* _objUI, int _startIndex, int _endIndex, bool _loop, bool _isLastFrameCall, const std::string& _varStr);        // 回调函数接口    virtual void    uiLastFrameCallFun(const std::string& _varStr);                                             // ui 动画播放到最后一帧回调此函数 _varStr,可以通过此参数传递一些需要的数据    virtual void    uiFrameEventCallFun(cocostudio::timeline::Frame* _frame, const std::string& _varStr);       // ui 动画事件帧回调此函数        public: // 骨骼动画相关函数        //    // _fileName, 带后缀文件名的文件名称，例如： test01.ExportJson    //    // 备注：带粒子的骨骼动画必须使用 .ExportJson 格式加载，不带粒子骨骼动画可以使用.csb 或者 .ExportJson 格式加载    //    Armature*       arLoad(int _tag, const std::string& _fileName, Vec2 _pos);      void            arFree(int _tag);    Armature*       arGet(int _tag);        void            arPlay(Armature* _objAr, const std::string& _animation);    void            arPlay(Armature* _objAr, const std::string& _animation, bool _loop);    void            arPlay(Armature* _objAr, const std::string& _animation, bool _loop, bool _isLastFrameCall, const std::string& _varStr);    void            arPlayFrameEvent(Armature* _objAr, const std::string& _animation, bool _loop, const std::string& _varStr);        // 回调函数    virtual void    arMovementEventCallFun(Armature *_objAr, MovementEventType _movementType, const std::string& _movementID, const std::string& _varStr);       // 动画播放事件--动画开始播放，动画播放结束时回调    virtual void    arFrameEventCallFun(cocostudio::Bone *_bone, const std::string& _evt, int _originFrameIndex, int _currentFrameIndex, const std::string& _varStr);  // 动画帧事件    public: // action 相关    // 移动    void            actMoveTo(Node* _node, float _time, Vec2 _dest, int _actTag = 0);    void            actMoveTo(Node* _node, float _time, Vec2 _dest, int _actTag, const std::string& _varStr); // 回调函数传递的配置字符串     // 缩放    void            actScale(Node* _node, float _time, float _scale, int _actTag = 0);    void            actScale(Node* _node, float _time, float _scale, int _actTag, const std::string& _varStr);    void            actScaleLoop(Node* _node, float _time, float _scale1, float _scale2, int _actTag = 0);    // 移入移出效果    void            actEaseIn(Node* _node, float _time, Vec2 _dest, int _actTag = 0);    void            actEaseIn(Node* _node, float _time, Vec2 _dest, int _actTag, const std::string& _varStr);        void            actEaseOut(Node* _node, float _time, Vec2 _dest, int _actTag = 0);    void            actEaseOut(Node* _node, float _time, Vec2 _dest, int _actTag, const std::string& _varStr);        // 淡入淡出效果    void            actFadeIn(Node* _node, float _time, int _actTag = 0);    void            actFadeIn(Node* _node, float _time, int _actTag, const std::string& _varStr);    void            actFadeout(Node* _node, float _time, int _actTag = 0);    void            actFadeout(Node* _node, float _time, int _actTag, const std::string& _varStr);        void            actFadeInOutLoop(Node* _node, float _time, int _actTag = 0);    void            actFadeOutInLoop(Node* _node, float _time, int _actTag = 0);        // 旋转动画 （平面旋转）    void            actRotateLoop(Node* _node, float _time, int _actTag = 0);			// 循环旋转(顺时针)， _time, 完成一次 360 度选择所需要的时间    void            actRotateTo(Node* _node, float _time, float _angle, int _actTag, const std::string& _varStr);        // 等待一段时间    void            actDelayTime(Node* _node, float _time, int _actTag, const std::string& _varStr);        // 回调函数    virtual void    actCallFun(Node* _node, int _actTag, const std::string& _varStr);  //  action 回调函数        public:      // ----------------------------------------------------    // 其他函数                };#endif // __BaseLayer_H__