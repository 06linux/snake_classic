#include "Base.h"#include "BaseLayer.h"BaseLayer::BaseLayer(){    _touchListener = NULL;    _keyboardListener = NULL;}BaseLayer::~BaseLayer(){    if(_touchListener)    {        _eventDispatcher->removeEventListener(_touchListener);        _touchListener = NULL;    }        if(_keyboardListener)    {        _eventDispatcher->removeEventListener(_keyboardListener);        _keyboardListener = NULL;    }}#pragma mark -#pragma mark --touch--bool BaseLayer::onTouchBegan(Touch *_touch, Event * _event){    return true;}void BaseLayer::onTouchEnded(Touch *_touch, Event * _event){}void BaseLayer::onTouchCancelled(Touch *_touch, Event * _event){}void BaseLayer::onTouchMoved(Touch *_touch, Event * _event){}Vec2 BaseLayer::getTouch(Touch* _touch, Event* _event){    Vec2 touchPoint;        if( NULL != _touch)    {        touchPoint = _touch->getLocation();    }        return touchPoint;}Vec2 BaseLayer::getTouch_Previous(Touch* _touch, Event* _event){    Vec2 touchPoint;        if( NULL != _touch)    {        touchPoint = _touch->getPreviousLocation();    }        return touchPoint;}void BaseLayer::setTouchListener(bool _isEnableTouch, int _priority){    if(NULL == _touchListener)    {        _touchListener = EventListenerTouchOneByOne::create();        _touchListener->setSwallowTouches(_isEnableTouch);        _touchListener->onTouchBegan = CC_CALLBACK_2(BaseLayer::onTouchBegan, this);        _touchListener->onTouchMoved = CC_CALLBACK_2(BaseLayer::onTouchMoved, this);        _touchListener->onTouchEnded = CC_CALLBACK_2(BaseLayer::onTouchEnded, this);        _touchListener->onTouchCancelled = CC_CALLBACK_2(BaseLayer::onTouchCancelled, this);        _eventDispatcher->addEventListenerWithFixedPriority(_touchListener, _priority);    }}void BaseLayer::onKeyPressed(EventKeyboard::KeyCode _code, Event* _event){}void BaseLayer::onKeyReleased(EventKeyboard::KeyCode _code, Event* _event){}void BaseLayer::setKeyboardListener(int _priority){    if(NULL == _keyboardListener)    {        _keyboardListener = EventListenerKeyboard::create();        _keyboardListener->onKeyPressed = CC_CALLBACK_2(BaseLayer::onKeyPressed, this);        _keyboardListener->onKeyReleased = CC_CALLBACK_2(BaseLayer::onKeyReleased, this);        _eventDispatcher->addEventListenerWithFixedPriority(_keyboardListener, _priority);    }}bool BaseLayer::isTouchOnNode(Node* _objNode, BasePoint _screenPos){    if(_objNode)    {        BasePoint touchPos = _screenPos;                // 得到 size 对象（如果存在 size 对象，优先使用 size 对象的区域进行判定）        Node* sizeNode = _objNode->getChildByName("size");        if(sizeNode)        {            if(sizeNode->getParent())            {                touchPos = sizeNode->getParent()->convertToNodeSpace(_screenPos);  // 转换为父亲对象中的相对坐标            }                        BasePoint       positon_objNode = sizeNode->getPosition();            BasePoint       anchor_objNode = sizeNode->getAnchorPoint();            float           scaleX_objNode = sizeNode->getScaleX();            float           scaleY_objNode = sizeNode->getScaleY();            BaseSize        size_objNode = sizeNode->getContentSize();                                    BaseRect rect = BaseRect(   positon_objNode.x - size_objNode.width*anchor_objNode.x*scaleX_objNode,                                     positon_objNode.y -  size_objNode.height*anchor_objNode.y*scaleY_objNode,                                     size_objNode.width*scaleX_objNode,                                     size_objNode.height*scaleY_objNode);                        if(rect.containsPoint(touchPos))            {                return true;            }        }                if(_objNode->getParent())        {            touchPos = _objNode->getParent()->convertToNodeSpace(_screenPos);  // 转换为父亲对象中的相对坐标        }                BasePoint       positon_objNode = _objNode->getPosition();        BasePoint       anchor_objNode = _objNode->getAnchorPoint();        float           scaleX_objNode = _objNode->getScaleX();        float           scaleY_objNode = _objNode->getScaleY();        BaseSize        size_objNode = _objNode->getContentSize();                       BaseRect rect = BaseRect(   positon_objNode.x - size_objNode.width*anchor_objNode.x*scaleX_objNode,                                 positon_objNode.y -  size_objNode.height*anchor_objNode.y*scaleY_objNode,                                 size_objNode.width*scaleX_objNode,                                 size_objNode.height*scaleY_objNode);                if(rect.containsPoint(touchPos))        {            return true;        }    }        return false;}#pragma mark -#pragma mark --ui--// 更新所有子类对象上的 action 的 tag 设置void BaseLayer_uiLoadSetActionTag(Node* _obj, int _tag){    if(NULL == _obj)    {        return;    }        auto& children = _obj->getChildren();    for (auto child : children)    {        cocostudio::timeline::ActionTimeline* actChild = dynamic_cast<cocostudio::timeline::ActionTimeline*>(child->getActionByTag(child->getTag()));        if(actChild)        {            CCLOG("BaseLayer_uiLoadSetActionTag, ActionTimeline, child = %s", child->getName().c_str());            actChild->setTag(_tag);   // 重新设置 tag 标志位        }                if(child->getChildrenCount() > 0)        {            BaseLayer_uiLoadSetActionTag(child, _tag);        }    }}Node* BaseLayer::uiLoad(int _tag, const std::string& _csbFileName, Vec2 _pos){    CCASSERT(_csbFileName.length() > 0, "BaseLayer::uiLoad, _csbFileName must not be NULL");     Node* obj = CSLoader::createNode(_csbFileName);    obj->setPosition(_pos);    addChild(obj, _tag, _tag);        cocostudio::timeline::ActionTimeline* objAction = CSLoader::createTimeline(_csbFileName);    if(objAction)    {        obj->runAction(objAction);        objAction->gotoFrameAndPause(0);  // 停在第一帧        objAction->setTag(BaseLayer::UI_ACTION_TAG);    }        BaseLayer_uiLoadSetActionTag(obj, BaseLayer::UI_ACTION_TAG);     return obj;}void  BaseLayer::uiFree(int _tag){    removeChildByTag(_tag);}Node* BaseLayer::uiGet(int _tag){    return getChildByTag(_tag);}Node* BaseLayer::uiGetChild(int _tag, const std::string& _childName){    Node* obj = getChildByTag(_tag);    if(obj)    {        return obj->getChildByName(_childName);    }    return NULL;}void BaseLayer::uiPlay(Node* _objUI, const std::string& _animation){    uiPlay(_objUI, _animation, true);}void  BaseLayer::uiPlay(Node* _objUI, const std::string& _animation, bool _loop){    uiPlay(_objUI, _animation, _loop, false, "null");}void  BaseLayer::uiPlay(Node* _objUI, const std::string& _animation, bool _loop, bool _isLastFrameCall, const std::string& _varStr){    CCASSERT(NULL != _objUI, "BaseLayer::uiPlay, _objUI must not be NULL");        cocostudio::timeline::ActionTimeline* objAction = dynamic_cast<cocostudio::timeline::ActionTimeline*>(_objUI->getActionByTag(BaseLayer::UI_ACTION_TAG));    if(objAction)    {        if(_isLastFrameCall)        {           objAction->setLastFrameCallFunc(CC_CALLBACK_0(BaseLayer::uiLastFrameCallFun, this, _varStr));        }        else        {            objAction->clearLastFrameCallFunc();        }                objAction->clearFrameEventCallFunc();        objAction->play(_animation,_loop);    }}void  BaseLayer::uiPlayFrameEvent(Node* _objUI, const std::string& _animation, bool _loop, const std::string& _varStr){    CCASSERT(NULL != _objUI, "BaseLayer::uiPlayFrameEvent, _objUI must not be NULL");        cocostudio::timeline::ActionTimeline* objAction = dynamic_cast<cocostudio::timeline::ActionTimeline*>(_objUI->getActionByTag(BaseLayer::UI_ACTION_TAG));    if(objAction)    {        objAction->clearLastFrameCallFunc();        objAction->setFrameEventCallFunc(CC_CALLBACK_0(BaseLayer::uiFrameEventCallFun, this, std::placeholders::_1, _varStr));        objAction->play(_animation,_loop);    }}void BaseLayer::uiGotoFrameAndPlay(Node* _objUI, int _startIndex){    uiGotoFrameAndPlay(_objUI, _startIndex, true, false, "null");}void BaseLayer::uiGotoFrameAndPlay(Node* _objUI, int _startIndex, bool _loop, bool _isLastFrameCall, const std::string& _varStr){    CCASSERT(NULL != _objUI, "BaseLayer::uiGotoFrameAndPlay,xx01, _objUI must not be NULL");        cocostudio::timeline::ActionTimeline* objAction = dynamic_cast<cocostudio::timeline::ActionTimeline*>(_objUI->getActionByTag(BaseLayer::UI_ACTION_TAG));    if(objAction)    {        if(_isLastFrameCall)        {            objAction->setLastFrameCallFunc(CC_CALLBACK_0(BaseLayer::uiLastFrameCallFun, this, _varStr));        }        else        {            objAction->clearLastFrameCallFunc();        }        objAction->clearFrameEventCallFunc();        objAction->gotoFrameAndPlay(_startIndex, objAction->getDuration(), _loop);    }    }void BaseLayer::uiGotoFrameAndPlay(Node* _objUI, int _startIndex, int _endIndex, bool _loop){    uiGotoFrameAndPlay(_objUI, _startIndex, _endIndex, _loop, false, "null");}void BaseLayer::uiGotoFrameAndPlay(Node* _objUI, int _startIndex, int _endIndex, bool _loop, bool _isLastFrameCall, const std::string& _varStr){    CCASSERT(NULL != _objUI, "BaseLayer::uiGotoFrameAndPlay,xx02, _objUI must not be NULL");        cocostudio::timeline::ActionTimeline* objAction = dynamic_cast<cocostudio::timeline::ActionTimeline*>(_objUI->getActionByTag(BaseLayer::UI_ACTION_TAG));    if(objAction)    {        if(_isLastFrameCall)        {            objAction->setLastFrameCallFunc(CC_CALLBACK_0(BaseLayer::uiLastFrameCallFun, this, _varStr));        }        else        {            objAction->clearLastFrameCallFunc();        }        objAction->clearFrameEventCallFunc();        objAction->gotoFrameAndPlay(_startIndex, _endIndex, _loop);    }}void BaseLayer::uiLastFrameCallFun(const std::string& _varStr){    }void BaseLayer::uiFrameEventCallFun(cocostudio::timeline::Frame* _frame, const std::string& _varStr){    }#pragma mark -#pragma mark --Armature--Armature* BaseLayer::arLoad(int _tag, const std::string& _fileName, Vec2 _pos){    size_t startPos = _fileName.find_last_of(".");    std::string strName = _fileName.substr(0, startPos);        //文件名    std::string strExtName = &_fileName[startPos+1];            //扩展名        // 先加载到缓冲池    ArmatureDataManager::getInstance()->addArmatureFileInfo(_fileName);        Armature *armature = Armature::create(strName);    armature->setPosition(_pos);    addChild(armature,_tag,_tag);        return armature;}void BaseLayer::arFree(int _tag){    removeChildByTag(_tag);}Armature* BaseLayer::arGet(int _tag){    return dynamic_cast<Armature*>(getChildByTag(_tag));}void BaseLayer::arPlay(Armature* _objAr, const std::string& _animation){    arPlay(_objAr, _animation, true);}void BaseLayer::arPlay(Armature* _objAr, const std::string& _animation, bool _loop){    arPlay(_objAr, _animation, _loop, false, "null");}void BaseLayer::arPlay(Armature* _objAr, const std::string& _animation, bool _loop, bool _isLastFrameCall, const std::string& _varStr){    CCASSERT(NULL != _objAr, "BaseLayer::arPlay, _objAr must not be NULL");        if(_isLastFrameCall)    {        // 动画事件回调        _objAr->getAnimation()->setMovementEventCallFunc(CC_CALLBACK_0(BaseLayer::arMovementEventCallFun, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, _varStr));    }    else    {        _objAr->getAnimation()->setMovementEventCallFunc(nullptr);    }        _objAr->getAnimation()->setFrameEventCallFunc(nullptr);  // 清除 frameEvent 回调    _objAr->getAnimation()->play(_animation, -1, (int)_loop);}void BaseLayer::arPlayFrameEvent(Armature* _objAr, const std::string& _animation, bool _loop, const std::string& _varStr){    CCASSERT(NULL != _objAr, "BaseLayer::arPlayFrameEvent, _objAr must not be NULL");        _objAr->getAnimation()->setMovementEventCallFunc(nullptr);  // 清除 movementEvent 回调    _objAr->getAnimation()->setFrameEventCallFunc(CC_CALLBACK_0(BaseLayer::arFrameEventCallFun, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, _varStr));    _objAr->getAnimation()->play(_animation, -1, (int)_loop);}void BaseLayer::arMovementEventCallFun(Armature *_objAr, MovementEventType _movementType, const std::string& _movementID, const std::string& _varStr){}void BaseLayer::arFrameEventCallFun(cocostudio::Bone *_bone, const std::string& _evt, int _originFrameIndex, int _currentFrameIndex, const std::string& _varStr){}#pragma mark -#pragma mark --action--void BaseLayer::actMoveTo(Node* _node, float _time, Vec2 _dest, int _actTag){    if(_node)    {        Action* action = MoveTo::create(_time ,  _dest);        _node->runAction(action);        action->setTag(_actTag);    }}void BaseLayer::actMoveTo(Node* _node, float _time, Vec2 _dest, int _actTag, const std::string& _varStr){    if(_node)    {        Action* action  = Sequence::create(                                MoveTo::create(_time,  _dest),                                CallFuncN::create(CC_CALLBACK_0(BaseLayer::actCallFun, this, std::placeholders::_1, _actTag, _varStr)),                                NULL);                _node->runAction(action);        action->setTag(_actTag);    }}void BaseLayer::actScale(Node* _node, float _time, float _scale, int _actTag){    if(_node)    {        Action* action = ScaleTo::create(_time, _scale);        _node->runAction(action);        action->setTag(_actTag);    }}void BaseLayer::actScale(Node* _node, float _time, float _scale, int _actTag, const std::string& _varStr){    if(_node)    {        Action* action = NULL;        action = Sequence::create(                                ScaleTo::create(_time, _scale),                                CallFuncN::create(CC_CALLBACK_0(BaseLayer::actCallFun, this, std::placeholders::_1, _actTag, _varStr)),                                NULL);                _node->runAction(action);        action->setTag(_actTag);    }}void BaseLayer::actScaleLoop(Node* _node, float _time, float _scale1, float _scale2, int _actTag){    if(_node)    {        Action* action = Sequence::create(                                    ScaleTo::create(_time/2.0f, _scale1),                                    ScaleTo::create(_time/2.0f, _scale2),                                    NULL                                    );                //_node->runAction(action);        _node->runAction(RepeatForever::create((ActionInterval*)action));        action->setTag(_actTag);    }}// 移入移出效果void actEaseIn(Node* _node, float _time, Vec2 _dest, int _actTag){    }void BaseLayer::actEaseIn(Node* _node, float _time, Vec2 _dest, int _actTag, const std::string& _varStr){    }void BaseLayer::actEaseOut(Node* _node, float _time, Vec2 _dest, int _actTag){    }void BaseLayer::actEaseOut(Node* _node, float _time, Vec2 _dest, int _actTag, const std::string& _varStr){    }void BaseLayer::actFadeIn(Node* _node, float _time, int _actTag){    }void BaseLayer::actFadeIn(Node* _node, float _time, int _actTag, const std::string& _varStr){    }void BaseLayer::actFadeout(Node* _node, float _time, int _actTag){    }void BaseLayer::actFadeout(Node* _node, float _time, int _actTag, const std::string& _varStr){    }void BaseLayer::actFadeInOutLoop(Node* _node, float _time, int _actTag){    }void BaseLayer::actFadeOutInLoop(Node* _node, float _time, int _actTag){    }void BaseLayer::actRotateLoop(Node* _node, float _time, int _actTag){    }void BaseLayer::actRotateTo(Node* _node, float _time, float _angle, int _actTag, const std::string& _varStr){    }void BaseLayer::actDelayTime(Node* _node, float _time, int _actTag, const std::string& _varStr){    if(_node)    {        Action* action = NULL;        action = Sequence::create(                                    DelayTime::create(_time),                                    CallFuncN::create(CC_CALLBACK_0(BaseLayer::actCallFun, this, std::placeholders::_1, _actTag, _varStr)),                                    NULL);                _node->runAction(action);        action->setTag(_actTag);    }}void BaseLayer::actCallFun(Node* _node, int _actTag, const std::string& _varStr){}